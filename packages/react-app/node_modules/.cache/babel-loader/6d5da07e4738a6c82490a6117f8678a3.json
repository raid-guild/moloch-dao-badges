{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst errcode = require('err-code');\n\nconst multihash = require('multihashes');\n\nconst crypto = require('./crypto');\n/**\n * Hash the given `buf` using the algorithm specified by `alg`.\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\n\n\nasync function Multihashing(buf, alg, length) {\n  const digest = await Multihashing.digest(buf, alg, length);\n  return multihash.encode(digest, alg, length);\n}\n/**\n * The `buffer` module for easy use in the browser.\n *\n * @type {Buffer}\n */\n\n\nMultihashing.Buffer = Buffer; // for browser things\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\n\nMultihashing.multihash = multihash;\n/**\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\n\nMultihashing.digest = async (buf, alg, length) => {\n  const hash = Multihashing.createHash(alg);\n  const digest = await hash(buf);\n  return length ? digest.slice(0, length) : digest;\n};\n/**\n * Creates a function that hashes with the given algorithm\n *\n * @param {string|number} alg - The algorithm to use eg 'sha1'\n *\n * @returns {function} - The hash function corresponding to `alg`\n */\n\n\nMultihashing.createHash = function (alg) {\n  if (!alg) {\n    throw errcode('hash algorithm must be specified', 'ERR_HASH_ALGORITHM_NOT_SPECIFIED');\n  }\n\n  alg = multihash.coerceCode(alg);\n\n  if (!Multihashing.functions[alg]) {\n    throw errcode(`multihash function '${alg}' not yet supported`, 'ERR_HASH_ALGORITHM_NOT_SUPPORTED');\n  }\n\n  return Multihashing.functions[alg];\n};\n/**\n * Mapping of multihash codes to their hashing functions.\n * @type {Object}\n */\n\n\nMultihashing.functions = {\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n}; // add blake functions\n\ncrypto.addBlake(Multihashing.functions);\n\nMultihashing.validate = async (buf, hash) => {\n  const newHash = await Multihashing(buf, multihash.decode(hash).name);\n  return Buffer.compare(hash, newHash) === 0;\n};\n\nmodule.exports = Multihashing;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs-unixfs-importer/node_modules/multihashing-async/src/index.js"],"names":["Buffer","require","errcode","multihash","crypto","Multihashing","buf","alg","length","digest","encode","hash","createHash","slice","coerceCode","functions","sha1","sha2256","sha2512","sha3512","sha3384","sha3256","sha3224","shake128","shake256","keccak224","keccak256","keccak384","keccak512","murmur3128","murmur332","dblSha2256","addBlake","validate","newHash","decode","name","compare","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst errcode = require('err-code')\nconst multihash = require('multihashes')\nconst crypto = require('./crypto')\n\n/**\n * Hash the given `buf` using the algorithm specified by `alg`.\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\nasync function Multihashing (buf, alg, length) {\n  const digest = await Multihashing.digest(buf, alg, length)\n  return multihash.encode(digest, alg, length)\n}\n\n/**\n * The `buffer` module for easy use in the browser.\n *\n * @type {Buffer}\n */\nMultihashing.Buffer = Buffer // for browser things\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\nMultihashing.multihash = multihash\n\n/**\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\nMultihashing.digest = async (buf, alg, length) => {\n  const hash = Multihashing.createHash(alg)\n  const digest = await hash(buf)\n  return length ? digest.slice(0, length) : digest\n}\n\n/**\n * Creates a function that hashes with the given algorithm\n *\n * @param {string|number} alg - The algorithm to use eg 'sha1'\n *\n * @returns {function} - The hash function corresponding to `alg`\n */\nMultihashing.createHash = function (alg) {\n  if (!alg) {\n    throw errcode('hash algorithm must be specified', 'ERR_HASH_ALGORITHM_NOT_SPECIFIED')\n  }\n\n  alg = multihash.coerceCode(alg)\n  if (!Multihashing.functions[alg]) {\n    throw errcode(`multihash function '${alg}' not yet supported`, 'ERR_HASH_ALGORITHM_NOT_SUPPORTED')\n  }\n\n  return Multihashing.functions[alg]\n}\n\n/**\n * Mapping of multihash codes to their hashing functions.\n * @type {Object}\n */\nMultihashing.functions = {\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n}\n\n// add blake functions\ncrypto.addBlake(Multihashing.functions)\n\nMultihashing.validate = async (buf, hash) => {\n  const newHash = await Multihashing(buf, multihash.decode(hash).name)\n\n  return Buffer.compare(hash, newHash) === 0\n}\n\nmodule.exports = Multihashing\n"]},"metadata":{},"sourceType":"script"}