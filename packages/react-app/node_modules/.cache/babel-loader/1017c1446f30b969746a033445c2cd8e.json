{"ast":null,"code":"'use strict';\n\nconst Clock = require('./lamport-clock');\n\nconst {\n  isDefined,\n  io\n} = require('./utils');\n\nconst stringify = require('json-stringify-deterministic');\n\nconst IpfsNotDefinedError = () => new Error('Ipfs instance not defined');\n\nconst IPLD_LINKS = ['next', 'refs'];\n\nconst getWriteFormatForVersion = v => v === 0 ? 'dag-pb' : 'dag-cbor';\n\nconst getWriteFormat = e => Entry.isEntry(e) ? getWriteFormatForVersion(e.v) : getWriteFormatForVersion(e);\n\nclass Entry {\n  /**\n   * Create an Entry\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {string} logId The unique identifier for this log\n   * @param {*} data Data of the entry to be added. Can be any JSON.stringifyable data\n   * @param {Array<string|Entry>} [next=[]] Parent hashes or entries\n   * @param {LamportClock} [clock] The lamport clock\n   * @returns {Promise<Entry>}\n   * @example\n   * const entry = await Entry.create(ipfs, identity, 'hello')\n   * console.log(entry)\n   * // { hash: null, payload: \"hello\", next: [] }\n   */\n  static async create(ipfs, identity, logId, data, next = [], clock, refs = [], pin) {\n    if (!isDefined(ipfs)) throw IpfsNotDefinedError();\n    if (!isDefined(identity)) throw new Error('Identity is required, cannot create entry');\n    if (!isDefined(logId)) throw new Error('Entry requires an id');\n    if (!isDefined(data)) throw new Error('Entry requires data');\n    if (!isDefined(next) || !Array.isArray(next)) throw new Error(\"'next' argument is not an array\"); // Clean the next objects and convert to hashes\n\n    const toEntry = e => e.hash ? e.hash : e;\n\n    const nexts = next.filter(isDefined).map(toEntry);\n    const entry = {\n      hash: null,\n      // \"zd...Foo\", we'll set the hash after persisting the entry\n      id: logId,\n      // For determining a unique chain\n      payload: data,\n      // Can be any JSON.stringifyable data\n      next: nexts,\n      // Array of hashes\n      refs: refs,\n      v: 2,\n      // To tag the version of this data structure\n      clock: clock || new Clock(identity.publicKey)\n    };\n    const signature = await identity.provider.sign(identity, Entry.toBuffer(entry));\n    entry.key = identity.publicKey;\n    entry.identity = identity.toJSON();\n    entry.sig = signature;\n    entry.hash = await Entry.toMultihash(ipfs, entry, pin);\n    return entry;\n  }\n  /**\n   * Verifies an entry signature.\n   *\n   * @param {IdentityProvider} identityProvider The identity provider to use\n   * @param {Entry} entry The entry being verified\n   * @return {Promise} A promise that resolves to a boolean value indicating if the signature is valid\n   */\n\n\n  static async verify(identityProvider, entry) {\n    if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry');\n    if (!Entry.isEntry(entry)) throw new Error('Invalid Log entry');\n    if (!entry.key) throw new Error(\"Entry doesn't have a key\");\n    if (!entry.sig) throw new Error(\"Entry doesn't have a signature\");\n    const e = Entry.toEntry(entry, {\n      presigned: true\n    });\n    const verifier = entry.v < 1 ? 'v0' : 'v1';\n    return identityProvider.verify(entry.sig, entry.key, Entry.toBuffer(e), verifier);\n  }\n  /**\n   * Transforms an entry into a Buffer.\n   * @param {Entry} entry The entry\n   * @return {Buffer} The buffer\n   */\n\n\n  static toBuffer(entry) {\n    const stringifiedEntry = entry.v === 0 ? JSON.stringify(entry) : stringify(entry);\n    return Buffer.from(stringifiedEntry);\n  }\n  /**\n   * Get the multihash of an Entry.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Entry} entry Entry to get a multihash for\n   * @returns {Promise<string>}\n   * @example\n   * const multihash = await Entry.toMultihash(ipfs, entry)\n   * console.log(multihash)\n   * // \"Qm...Foo\"\n   * @deprecated\n   */\n\n\n  static async toMultihash(ipfs, entry, pin = false) {\n    if (!ipfs) throw IpfsNotDefinedError();\n    if (!Entry.isEntry(entry)) throw new Error('Invalid object format, cannot generate entry hash'); // // Ensure `entry` follows the correct format\n\n    const e = Entry.toEntry(entry);\n    return io.write(ipfs, getWriteFormat(e.v), e, {\n      links: IPLD_LINKS,\n      pin\n    });\n  }\n\n  static toEntry(entry, {\n    presigned = false,\n    includeHash = false\n  } = {}) {\n    const e = {\n      hash: includeHash ? entry.hash : null,\n      id: entry.id,\n      payload: entry.payload,\n      next: entry.next\n    };\n    const v = entry.v;\n\n    if (v > 1) {\n      e.refs = entry.refs; // added in v2\n    }\n\n    e.v = entry.v;\n    e.clock = new Clock(entry.clock.id, entry.clock.time);\n\n    if (presigned) {\n      return e; // don't include key/sig information\n    }\n\n    e.key = entry.key;\n\n    if (v > 0) {\n      e.identity = entry.identity; // added in v1\n    }\n\n    e.sig = entry.sig;\n    return e;\n  }\n  /**\n   * Create an Entry from a hash.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {string} hash The hash to create an Entry from\n   * @returns {Promise<Entry>}\n   * @example\n   * const entry = await Entry.fromMultihash(ipfs, \"zd...Foo\")\n   * console.log(entry)\n   * // { hash: \"Zd...Foo\", payload: \"hello\", next: [] }\n   */\n\n\n  static async fromMultihash(ipfs, hash) {\n    if (!ipfs) throw IpfsNotDefinedError();\n    if (!hash) throw new Error(`Invalid hash: ${hash}`);\n    const e = await io.read(ipfs, hash, {\n      links: IPLD_LINKS\n    });\n    const entry = Entry.toEntry(e);\n    entry.hash = hash;\n    return entry;\n  }\n  /**\n   * Check if an object is an Entry.\n   * @param {Entry} obj\n   * @returns {boolean}\n   */\n\n\n  static isEntry(obj) {\n    return obj && obj.id !== undefined && obj.next !== undefined && obj.payload !== undefined && obj.v !== undefined && obj.hash !== undefined && obj.clock !== undefined && (obj.refs !== undefined || obj.v < 2); // 'refs' added in v2\n  }\n  /**\n   * Compares two entries.\n   * @param {Entry} a\n   * @param {Entry} b\n   * @returns {number} 1 if a is greater, -1 is b is greater\n   */\n\n\n  static compare(a, b) {\n    var distance = Clock.compare(a.clock, b.clock);\n    if (distance === 0) return a.clock.id < b.clock.id ? -1 : 1;\n    return distance;\n  }\n  /**\n   * Check if an entry equals another entry.\n   * @param {Entry} a\n   * @param {Entry} b\n   * @returns {boolean}\n   */\n\n\n  static isEqual(a, b) {\n    return a.hash === b.hash;\n  }\n  /**\n   * Check if an entry is a parent to another entry.\n   * @param {Entry} entry1 Entry to check\n   * @param {Entry} entry2 The parent Entry\n   * @returns {boolean}\n   */\n\n\n  static isParent(entry1, entry2) {\n    return entry2.next.indexOf(entry1.hash) > -1;\n  }\n  /**\n   * Find entry's children from an Array of entries.\n   * Returns entry's children as an Array up to the last know child.\n   * @param {Entry} entry Entry for which to find the parents\n   * @param {Array<Entry>} values Entries to search parents from\n   * @returns {Array<Entry>}\n   */\n\n\n  static findChildren(entry, values) {\n    var stack = [];\n    var parent = values.find(e => Entry.isParent(entry, e));\n    var prev = entry;\n\n    while (parent) {\n      stack.push(parent);\n      prev = parent;\n      parent = values.find(e => Entry.isParent(prev, e));\n    }\n\n    stack = stack.sort((a, b) => a.clock.time > b.clock.time);\n    return stack;\n  }\n\n}\n\nmodule.exports = Entry;\nmodule.exports.IPLD_LINKS = IPLD_LINKS;\nmodule.exports.getWriteFormat = getWriteFormat;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-log/src/entry.js"],"names":["Clock","require","isDefined","io","stringify","IpfsNotDefinedError","Error","IPLD_LINKS","getWriteFormatForVersion","v","getWriteFormat","e","Entry","isEntry","create","ipfs","identity","logId","data","next","clock","refs","pin","Array","isArray","toEntry","hash","nexts","filter","map","entry","id","payload","publicKey","signature","provider","sign","toBuffer","key","toJSON","sig","toMultihash","verify","identityProvider","presigned","verifier","stringifiedEntry","JSON","Buffer","from","write","links","includeHash","time","fromMultihash","read","obj","undefined","compare","a","b","distance","isEqual","isParent","entry1","entry2","indexOf","findChildren","values","stack","parent","find","prev","push","sort","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,iBAAD,CAArB;;AACA,MAAM;AAAEC,EAAAA,SAAF;AAAaC,EAAAA;AAAb,IAAoBF,OAAO,CAAC,SAAD,CAAjC;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,8BAAD,CAAzB;;AACA,MAAMI,mBAAmB,GAAG,MAAM,IAAIC,KAAJ,CAAU,2BAAV,CAAlC;;AACA,MAAMC,UAAU,GAAG,CAAC,MAAD,EAAS,MAAT,CAAnB;;AACA,MAAMC,wBAAwB,GAAGC,CAAC,IAAIA,CAAC,KAAK,CAAN,GAAU,QAAV,GAAqB,UAA3D;;AACA,MAAMC,cAAc,GAAGC,CAAC,IAAIC,KAAK,CAACC,OAAN,CAAcF,CAAd,IAAmBH,wBAAwB,CAACG,CAAC,CAACF,CAAH,CAA3C,GAAmDD,wBAAwB,CAACG,CAAD,CAAvG;;AAEA,MAAMC,KAAN,CAAY;AACV;;;;;;;;;;;;;;AAcA,eAAaE,MAAb,CAAqBC,IAArB,EAA2BC,QAA3B,EAAqCC,KAArC,EAA4CC,IAA5C,EAAkDC,IAAI,GAAG,EAAzD,EAA6DC,KAA7D,EAAoEC,IAAI,GAAG,EAA3E,EAA+EC,GAA/E,EAAoF;AAClF,QAAI,CAACpB,SAAS,CAACa,IAAD,CAAd,EAAsB,MAAMV,mBAAmB,EAAzB;AACtB,QAAI,CAACH,SAAS,CAACc,QAAD,CAAd,EAA0B,MAAM,IAAIV,KAAJ,CAAU,2CAAV,CAAN;AAC1B,QAAI,CAACJ,SAAS,CAACe,KAAD,CAAd,EAAuB,MAAM,IAAIX,KAAJ,CAAU,sBAAV,CAAN;AACvB,QAAI,CAACJ,SAAS,CAACgB,IAAD,CAAd,EAAsB,MAAM,IAAIZ,KAAJ,CAAU,qBAAV,CAAN;AACtB,QAAI,CAACJ,SAAS,CAACiB,IAAD,CAAV,IAAoB,CAACI,KAAK,CAACC,OAAN,CAAcL,IAAd,CAAzB,EAA8C,MAAM,IAAIb,KAAJ,CAAU,iCAAV,CAAN,CALoC,CAOlF;;AACA,UAAMmB,OAAO,GAAId,CAAD,IAAOA,CAAC,CAACe,IAAF,GAASf,CAAC,CAACe,IAAX,GAAkBf,CAAzC;;AACA,UAAMgB,KAAK,GAAGR,IAAI,CAACS,MAAL,CAAY1B,SAAZ,EAAuB2B,GAAvB,CAA2BJ,OAA3B,CAAd;AAEA,UAAMK,KAAK,GAAG;AACZJ,MAAAA,IAAI,EAAE,IADM;AACA;AACZK,MAAAA,EAAE,EAAEd,KAFQ;AAED;AACXe,MAAAA,OAAO,EAAEd,IAHG;AAGG;AACfC,MAAAA,IAAI,EAAEQ,KAJM;AAIC;AACbN,MAAAA,IAAI,EAAEA,IALM;AAMZZ,MAAAA,CAAC,EAAE,CANS;AAMN;AACNW,MAAAA,KAAK,EAAEA,KAAK,IAAI,IAAIpB,KAAJ,CAAUgB,QAAQ,CAACiB,SAAnB;AAPJ,KAAd;AAUA,UAAMC,SAAS,GAAG,MAAMlB,QAAQ,CAACmB,QAAT,CAAkBC,IAAlB,CAAuBpB,QAAvB,EAAiCJ,KAAK,CAACyB,QAAN,CAAeP,KAAf,CAAjC,CAAxB;AAEAA,IAAAA,KAAK,CAACQ,GAAN,GAAYtB,QAAQ,CAACiB,SAArB;AACAH,IAAAA,KAAK,CAACd,QAAN,GAAiBA,QAAQ,CAACuB,MAAT,EAAjB;AACAT,IAAAA,KAAK,CAACU,GAAN,GAAYN,SAAZ;AACAJ,IAAAA,KAAK,CAACJ,IAAN,GAAa,MAAMd,KAAK,CAAC6B,WAAN,CAAkB1B,IAAlB,EAAwBe,KAAxB,EAA+BR,GAA/B,CAAnB;AAEA,WAAOQ,KAAP;AACD;AAED;;;;;;;;;AAOA,eAAaY,MAAb,CAAqBC,gBAArB,EAAuCb,KAAvC,EAA8C;AAC5C,QAAI,CAACa,gBAAL,EAAuB,MAAM,IAAIrC,KAAJ,CAAU,oDAAV,CAAN;AACvB,QAAI,CAACM,KAAK,CAACC,OAAN,CAAciB,KAAd,CAAL,EAA2B,MAAM,IAAIxB,KAAJ,CAAU,mBAAV,CAAN;AAC3B,QAAI,CAACwB,KAAK,CAACQ,GAAX,EAAgB,MAAM,IAAIhC,KAAJ,CAAU,0BAAV,CAAN;AAChB,QAAI,CAACwB,KAAK,CAACU,GAAX,EAAgB,MAAM,IAAIlC,KAAJ,CAAU,gCAAV,CAAN;AAEhB,UAAMK,CAAC,GAAGC,KAAK,CAACa,OAAN,CAAcK,KAAd,EAAqB;AAAEc,MAAAA,SAAS,EAAE;AAAb,KAArB,CAAV;AACA,UAAMC,QAAQ,GAAGf,KAAK,CAACrB,CAAN,GAAU,CAAV,GAAc,IAAd,GAAqB,IAAtC;AACA,WAAOkC,gBAAgB,CAACD,MAAjB,CAAwBZ,KAAK,CAACU,GAA9B,EAAmCV,KAAK,CAACQ,GAAzC,EAA8C1B,KAAK,CAACyB,QAAN,CAAe1B,CAAf,CAA9C,EAAiEkC,QAAjE,CAAP;AACD;AAED;;;;;;;AAKA,SAAOR,QAAP,CAAiBP,KAAjB,EAAwB;AACtB,UAAMgB,gBAAgB,GAAGhB,KAAK,CAACrB,CAAN,KAAY,CAAZ,GAAgBsC,IAAI,CAAC3C,SAAL,CAAe0B,KAAf,CAAhB,GAAwC1B,SAAS,CAAC0B,KAAD,CAA1E;AACA,WAAOkB,MAAM,CAACC,IAAP,CAAYH,gBAAZ,CAAP;AACD;AAED;;;;;;;;;;;;;AAWA,eAAaL,WAAb,CAA0B1B,IAA1B,EAAgCe,KAAhC,EAAuCR,GAAG,GAAG,KAA7C,EAAoD;AAClD,QAAI,CAACP,IAAL,EAAW,MAAMV,mBAAmB,EAAzB;AACX,QAAI,CAACO,KAAK,CAACC,OAAN,CAAciB,KAAd,CAAL,EAA2B,MAAM,IAAIxB,KAAJ,CAAU,mDAAV,CAAN,CAFuB,CAIlD;;AACA,UAAMK,CAAC,GAAGC,KAAK,CAACa,OAAN,CAAcK,KAAd,CAAV;AACA,WAAO3B,EAAE,CAAC+C,KAAH,CAASnC,IAAT,EAAeL,cAAc,CAACC,CAAC,CAACF,CAAH,CAA7B,EAAoCE,CAApC,EAAuC;AAAEwC,MAAAA,KAAK,EAAE5C,UAAT;AAAqBe,MAAAA;AAArB,KAAvC,CAAP;AACD;;AAED,SAAOG,OAAP,CAAgBK,KAAhB,EAAuB;AAAEc,IAAAA,SAAS,GAAG,KAAd;AAAqBQ,IAAAA,WAAW,GAAG;AAAnC,MAA6C,EAApE,EAAwE;AACtE,UAAMzC,CAAC,GAAG;AACRe,MAAAA,IAAI,EAAE0B,WAAW,GAAGtB,KAAK,CAACJ,IAAT,GAAgB,IADzB;AAERK,MAAAA,EAAE,EAAED,KAAK,CAACC,EAFF;AAGRC,MAAAA,OAAO,EAAEF,KAAK,CAACE,OAHP;AAIRb,MAAAA,IAAI,EAAEW,KAAK,CAACX;AAJJ,KAAV;AAOA,UAAMV,CAAC,GAAGqB,KAAK,CAACrB,CAAhB;;AACA,QAAIA,CAAC,GAAG,CAAR,EAAW;AACTE,MAAAA,CAAC,CAACU,IAAF,GAASS,KAAK,CAACT,IAAf,CADS,CACW;AACrB;;AACDV,IAAAA,CAAC,CAACF,CAAF,GAAMqB,KAAK,CAACrB,CAAZ;AACAE,IAAAA,CAAC,CAACS,KAAF,GAAU,IAAIpB,KAAJ,CAAU8B,KAAK,CAACV,KAAN,CAAYW,EAAtB,EAA0BD,KAAK,CAACV,KAAN,CAAYiC,IAAtC,CAAV;;AAEA,QAAIT,SAAJ,EAAe;AACb,aAAOjC,CAAP,CADa,CACJ;AACV;;AAEDA,IAAAA,CAAC,CAAC2B,GAAF,GAAQR,KAAK,CAACQ,GAAd;;AACA,QAAI7B,CAAC,GAAG,CAAR,EAAW;AACTE,MAAAA,CAAC,CAACK,QAAF,GAAac,KAAK,CAACd,QAAnB,CADS,CACmB;AAC7B;;AACDL,IAAAA,CAAC,CAAC6B,GAAF,GAAQV,KAAK,CAACU,GAAd;AACA,WAAO7B,CAAP;AACD;AAED;;;;;;;;;;;;AAUA,eAAa2C,aAAb,CAA4BvC,IAA5B,EAAkCW,IAAlC,EAAwC;AACtC,QAAI,CAACX,IAAL,EAAW,MAAMV,mBAAmB,EAAzB;AACX,QAAI,CAACqB,IAAL,EAAW,MAAM,IAAIpB,KAAJ,CAAW,iBAAgBoB,IAAK,EAAhC,CAAN;AACX,UAAMf,CAAC,GAAG,MAAMR,EAAE,CAACoD,IAAH,CAAQxC,IAAR,EAAcW,IAAd,EAAoB;AAAEyB,MAAAA,KAAK,EAAE5C;AAAT,KAApB,CAAhB;AAEA,UAAMuB,KAAK,GAAGlB,KAAK,CAACa,OAAN,CAAcd,CAAd,CAAd;AACAmB,IAAAA,KAAK,CAACJ,IAAN,GAAaA,IAAb;AAEA,WAAOI,KAAP;AACD;AAED;;;;;;;AAKA,SAAOjB,OAAP,CAAgB2C,GAAhB,EAAqB;AACnB,WAAOA,GAAG,IAAIA,GAAG,CAACzB,EAAJ,KAAW0B,SAAlB,IACLD,GAAG,CAACrC,IAAJ,KAAasC,SADR,IAELD,GAAG,CAACxB,OAAJ,KAAgByB,SAFX,IAGLD,GAAG,CAAC/C,CAAJ,KAAUgD,SAHL,IAILD,GAAG,CAAC9B,IAAJ,KAAa+B,SAJR,IAKLD,GAAG,CAACpC,KAAJ,KAAcqC,SALT,KAMJD,GAAG,CAACnC,IAAJ,KAAaoC,SAAb,IAA0BD,GAAG,CAAC/C,CAAJ,GAAQ,CAN9B,CAAP,CADmB,CAOqB;AACzC;AAED;;;;;;;;AAMA,SAAOiD,OAAP,CAAgBC,CAAhB,EAAmBC,CAAnB,EAAsB;AACpB,QAAIC,QAAQ,GAAG7D,KAAK,CAAC0D,OAAN,CAAcC,CAAC,CAACvC,KAAhB,EAAuBwC,CAAC,CAACxC,KAAzB,CAAf;AACA,QAAIyC,QAAQ,KAAK,CAAjB,EAAoB,OAAOF,CAAC,CAACvC,KAAF,CAAQW,EAAR,GAAa6B,CAAC,CAACxC,KAAF,CAAQW,EAArB,GAA0B,CAAC,CAA3B,GAA+B,CAAtC;AACpB,WAAO8B,QAAP;AACD;AAED;;;;;;;;AAMA,SAAOC,OAAP,CAAgBH,CAAhB,EAAmBC,CAAnB,EAAsB;AACpB,WAAOD,CAAC,CAACjC,IAAF,KAAWkC,CAAC,CAAClC,IAApB;AACD;AAED;;;;;;;;AAMA,SAAOqC,QAAP,CAAiBC,MAAjB,EAAyBC,MAAzB,EAAiC;AAC/B,WAAOA,MAAM,CAAC9C,IAAP,CAAY+C,OAAZ,CAAoBF,MAAM,CAACtC,IAA3B,IAAmC,CAAC,CAA3C;AACD;AAED;;;;;;;;;AAOA,SAAOyC,YAAP,CAAqBrC,KAArB,EAA4BsC,MAA5B,EAAoC;AAClC,QAAIC,KAAK,GAAG,EAAZ;AACA,QAAIC,MAAM,GAAGF,MAAM,CAACG,IAAP,CAAa5D,CAAD,IAAOC,KAAK,CAACmD,QAAN,CAAejC,KAAf,EAAsBnB,CAAtB,CAAnB,CAAb;AACA,QAAI6D,IAAI,GAAG1C,KAAX;;AACA,WAAOwC,MAAP,EAAe;AACbD,MAAAA,KAAK,CAACI,IAAN,CAAWH,MAAX;AACAE,MAAAA,IAAI,GAAGF,MAAP;AACAA,MAAAA,MAAM,GAAGF,MAAM,CAACG,IAAP,CAAa5D,CAAD,IAAOC,KAAK,CAACmD,QAAN,CAAeS,IAAf,EAAqB7D,CAArB,CAAnB,CAAT;AACD;;AACD0D,IAAAA,KAAK,GAAGA,KAAK,CAACK,IAAN,CAAW,CAACf,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACvC,KAAF,CAAQiC,IAAR,GAAeO,CAAC,CAACxC,KAAF,CAAQiC,IAA5C,CAAR;AACA,WAAOgB,KAAP;AACD;;AA/MS;;AAkNZM,MAAM,CAACC,OAAP,GAAiBhE,KAAjB;AACA+D,MAAM,CAACC,OAAP,CAAerE,UAAf,GAA4BA,UAA5B;AACAoE,MAAM,CAACC,OAAP,CAAelE,cAAf,GAAgCA,cAAhC","sourcesContent":["'use strict'\n\nconst Clock = require('./lamport-clock')\nconst { isDefined, io } = require('./utils')\nconst stringify = require('json-stringify-deterministic')\nconst IpfsNotDefinedError = () => new Error('Ipfs instance not defined')\nconst IPLD_LINKS = ['next', 'refs']\nconst getWriteFormatForVersion = v => v === 0 ? 'dag-pb' : 'dag-cbor'\nconst getWriteFormat = e => Entry.isEntry(e) ? getWriteFormatForVersion(e.v) : getWriteFormatForVersion(e)\n\nclass Entry {\n  /**\n   * Create an Entry\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {string} logId The unique identifier for this log\n   * @param {*} data Data of the entry to be added. Can be any JSON.stringifyable data\n   * @param {Array<string|Entry>} [next=[]] Parent hashes or entries\n   * @param {LamportClock} [clock] The lamport clock\n   * @returns {Promise<Entry>}\n   * @example\n   * const entry = await Entry.create(ipfs, identity, 'hello')\n   * console.log(entry)\n   * // { hash: null, payload: \"hello\", next: [] }\n   */\n  static async create (ipfs, identity, logId, data, next = [], clock, refs = [], pin) {\n    if (!isDefined(ipfs)) throw IpfsNotDefinedError()\n    if (!isDefined(identity)) throw new Error('Identity is required, cannot create entry')\n    if (!isDefined(logId)) throw new Error('Entry requires an id')\n    if (!isDefined(data)) throw new Error('Entry requires data')\n    if (!isDefined(next) || !Array.isArray(next)) throw new Error(\"'next' argument is not an array\")\n\n    // Clean the next objects and convert to hashes\n    const toEntry = (e) => e.hash ? e.hash : e\n    const nexts = next.filter(isDefined).map(toEntry)\n\n    const entry = {\n      hash: null, // \"zd...Foo\", we'll set the hash after persisting the entry\n      id: logId, // For determining a unique chain\n      payload: data, // Can be any JSON.stringifyable data\n      next: nexts, // Array of hashes\n      refs: refs,\n      v: 2, // To tag the version of this data structure\n      clock: clock || new Clock(identity.publicKey)\n    }\n\n    const signature = await identity.provider.sign(identity, Entry.toBuffer(entry))\n\n    entry.key = identity.publicKey\n    entry.identity = identity.toJSON()\n    entry.sig = signature\n    entry.hash = await Entry.toMultihash(ipfs, entry, pin)\n\n    return entry\n  }\n\n  /**\n   * Verifies an entry signature.\n   *\n   * @param {IdentityProvider} identityProvider The identity provider to use\n   * @param {Entry} entry The entry being verified\n   * @return {Promise} A promise that resolves to a boolean value indicating if the signature is valid\n   */\n  static async verify (identityProvider, entry) {\n    if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry')\n    if (!Entry.isEntry(entry)) throw new Error('Invalid Log entry')\n    if (!entry.key) throw new Error(\"Entry doesn't have a key\")\n    if (!entry.sig) throw new Error(\"Entry doesn't have a signature\")\n\n    const e = Entry.toEntry(entry, { presigned: true })\n    const verifier = entry.v < 1 ? 'v0' : 'v1'\n    return identityProvider.verify(entry.sig, entry.key, Entry.toBuffer(e), verifier)\n  }\n\n  /**\n   * Transforms an entry into a Buffer.\n   * @param {Entry} entry The entry\n   * @return {Buffer} The buffer\n   */\n  static toBuffer (entry) {\n    const stringifiedEntry = entry.v === 0 ? JSON.stringify(entry) : stringify(entry)\n    return Buffer.from(stringifiedEntry)\n  }\n\n  /**\n   * Get the multihash of an Entry.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Entry} entry Entry to get a multihash for\n   * @returns {Promise<string>}\n   * @example\n   * const multihash = await Entry.toMultihash(ipfs, entry)\n   * console.log(multihash)\n   * // \"Qm...Foo\"\n   * @deprecated\n   */\n  static async toMultihash (ipfs, entry, pin = false) {\n    if (!ipfs) throw IpfsNotDefinedError()\n    if (!Entry.isEntry(entry)) throw new Error('Invalid object format, cannot generate entry hash')\n\n    // // Ensure `entry` follows the correct format\n    const e = Entry.toEntry(entry)\n    return io.write(ipfs, getWriteFormat(e.v), e, { links: IPLD_LINKS, pin })\n  }\n\n  static toEntry (entry, { presigned = false, includeHash = false } = {}) {\n    const e = {\n      hash: includeHash ? entry.hash : null,\n      id: entry.id,\n      payload: entry.payload,\n      next: entry.next\n    }\n\n    const v = entry.v\n    if (v > 1) {\n      e.refs = entry.refs // added in v2\n    }\n    e.v = entry.v\n    e.clock = new Clock(entry.clock.id, entry.clock.time)\n\n    if (presigned) {\n      return e // don't include key/sig information\n    }\n\n    e.key = entry.key\n    if (v > 0) {\n      e.identity = entry.identity // added in v1\n    }\n    e.sig = entry.sig\n    return e\n  }\n\n  /**\n   * Create an Entry from a hash.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {string} hash The hash to create an Entry from\n   * @returns {Promise<Entry>}\n   * @example\n   * const entry = await Entry.fromMultihash(ipfs, \"zd...Foo\")\n   * console.log(entry)\n   * // { hash: \"Zd...Foo\", payload: \"hello\", next: [] }\n   */\n  static async fromMultihash (ipfs, hash) {\n    if (!ipfs) throw IpfsNotDefinedError()\n    if (!hash) throw new Error(`Invalid hash: ${hash}`)\n    const e = await io.read(ipfs, hash, { links: IPLD_LINKS })\n\n    const entry = Entry.toEntry(e)\n    entry.hash = hash\n\n    return entry\n  }\n\n  /**\n   * Check if an object is an Entry.\n   * @param {Entry} obj\n   * @returns {boolean}\n   */\n  static isEntry (obj) {\n    return obj && obj.id !== undefined &&\n      obj.next !== undefined &&\n      obj.payload !== undefined &&\n      obj.v !== undefined &&\n      obj.hash !== undefined &&\n      obj.clock !== undefined &&\n      (obj.refs !== undefined || obj.v < 2) // 'refs' added in v2\n  }\n\n  /**\n   * Compares two entries.\n   * @param {Entry} a\n   * @param {Entry} b\n   * @returns {number} 1 if a is greater, -1 is b is greater\n   */\n  static compare (a, b) {\n    var distance = Clock.compare(a.clock, b.clock)\n    if (distance === 0) return a.clock.id < b.clock.id ? -1 : 1\n    return distance\n  }\n\n  /**\n   * Check if an entry equals another entry.\n   * @param {Entry} a\n   * @param {Entry} b\n   * @returns {boolean}\n   */\n  static isEqual (a, b) {\n    return a.hash === b.hash\n  }\n\n  /**\n   * Check if an entry is a parent to another entry.\n   * @param {Entry} entry1 Entry to check\n   * @param {Entry} entry2 The parent Entry\n   * @returns {boolean}\n   */\n  static isParent (entry1, entry2) {\n    return entry2.next.indexOf(entry1.hash) > -1\n  }\n\n  /**\n   * Find entry's children from an Array of entries.\n   * Returns entry's children as an Array up to the last know child.\n   * @param {Entry} entry Entry for which to find the parents\n   * @param {Array<Entry>} values Entries to search parents from\n   * @returns {Array<Entry>}\n   */\n  static findChildren (entry, values) {\n    var stack = []\n    var parent = values.find((e) => Entry.isParent(entry, e))\n    var prev = entry\n    while (parent) {\n      stack.push(parent)\n      prev = parent\n      parent = values.find((e) => Entry.isParent(prev, e))\n    }\n    stack = stack.sort((a, b) => a.clock.time > b.clock.time)\n    return stack\n  }\n}\n\nmodule.exports = Entry\nmodule.exports.IPLD_LINKS = IPLD_LINKS\nmodule.exports.getWriteFormat = getWriteFormat\n"]},"metadata":{},"sourceType":"script"}