{"ast":null,"code":"'use strict';\n\nrequire('node-forge/lib/pkcs7');\n\nrequire('node-forge/lib/pbe');\n\nconst forge = require('node-forge/lib/forge');\n\nconst {\n  certificateForKey,\n  findAsync\n} = require('./util');\n\nconst errcode = require('err-code');\n/**\n * Cryptographic Message Syntax (aka PKCS #7)\n *\n * CMS describes an encapsulation syntax for data protection. It\n * is used to digitally sign, digest, authenticate, or encrypt\n * arbitrary message content.\n *\n * See RFC 5652 for all the details.\n */\n\n\nclass CMS {\n  /**\n   * Creates a new instance with a keychain\n   *\n   * @param {Keychain} keychain - the available keys\n   */\n  constructor(keychain) {\n    if (!keychain) {\n      throw errcode(new Error('keychain is required'), 'ERR_KEYCHAIN_REQUIRED');\n    }\n\n    this.keychain = keychain;\n  }\n  /**\n   * Creates some protected data.\n   *\n   * The output Buffer contains the PKCS #7 message in DER.\n   *\n   * @param {string} name - The local key name.\n   * @param {Buffer} plain - The data to encrypt.\n   * @returns {undefined}\n   */\n\n\n  async encrypt(name, plain) {\n    if (!Buffer.isBuffer(plain)) {\n      throw errcode(new Error('Plain data must be a Buffer'), 'ERR_INVALID_PARAMS');\n    }\n\n    const key = await this.keychain.findKeyByName(name);\n    const pem = await this.keychain._getPrivateKey(name);\n    const privateKey = forge.pki.decryptRsaPrivateKey(pem, this.keychain._());\n    const certificate = await certificateForKey(key, privateKey); // create a p7 enveloped message\n\n    const p7 = forge.pkcs7.createEnvelopedData();\n    p7.addRecipient(certificate);\n    p7.content = forge.util.createBuffer(plain);\n    p7.encrypt(); // convert message to DER\n\n    const der = forge.asn1.toDer(p7.toAsn1()).getBytes();\n    return Buffer.from(der, 'binary');\n  }\n  /**\n   * Reads some protected data.\n   *\n   * The keychain must contain one of the keys used to encrypt the data.  If none of the keys\n   * exists, an Error is returned with the property 'missingKeys'.  It is array of key ids.\n   *\n   * @param {Buffer} cmsData - The CMS encrypted data to decrypt.\n   * @returns {undefined}\n   */\n\n\n  async decrypt(cmsData) {\n    if (!Buffer.isBuffer(cmsData)) {\n      throw errcode(new Error('CMS data is required'), 'ERR_INVALID_PARAMS');\n    }\n\n    let cms;\n\n    try {\n      const buf = forge.util.createBuffer(cmsData.toString('binary'));\n      const obj = forge.asn1.fromDer(buf);\n      cms = forge.pkcs7.messageFromAsn1(obj);\n    } catch (err) {\n      throw errcode(new Error('Invalid CMS: ' + err.message), 'ERR_INVALID_CMS');\n    } // Find a recipient whose key we hold. We only deal with recipient certs\n    // issued by ipfs (O=ipfs).\n\n\n    const recipients = cms.recipients.filter(r => r.issuer.find(a => a.shortName === 'O' && a.value === 'ipfs')).filter(r => r.issuer.find(a => a.shortName === 'CN')).map(r => {\n      return {\n        recipient: r,\n        keyId: r.issuer.find(a => a.shortName === 'CN').value\n      };\n    });\n    const r = await findAsync(recipients, async recipient => {\n      try {\n        const key = await this.keychain.findKeyById(recipient.keyId);\n        if (key) return true;\n      } catch (err) {\n        return false;\n      }\n\n      return false;\n    });\n\n    if (!r) {\n      const missingKeys = recipients.map(r => r.keyId);\n      throw errcode(new Error('Decryption needs one of the key(s): ' + missingKeys.join(', ')), 'ERR_MISSING_KEYS', {\n        missingKeys\n      });\n    }\n\n    const key = await this.keychain.findKeyById(r.keyId);\n    const pem = await this.keychain._getPrivateKey(key.name);\n    const privateKey = forge.pki.decryptRsaPrivateKey(pem, this.keychain._());\n    cms.decrypt(r.recipient, privateKey);\n    return Buffer.from(cms.content.getBytes(), 'binary');\n  }\n\n}\n\nmodule.exports = CMS;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-keychain/src/cms.js"],"names":["require","forge","certificateForKey","findAsync","errcode","CMS","constructor","keychain","Error","encrypt","name","plain","Buffer","isBuffer","key","findKeyByName","pem","_getPrivateKey","privateKey","pki","decryptRsaPrivateKey","_","certificate","p7","pkcs7","createEnvelopedData","addRecipient","content","util","createBuffer","der","asn1","toDer","toAsn1","getBytes","from","decrypt","cmsData","cms","buf","toString","obj","fromDer","messageFromAsn1","err","message","recipients","filter","r","issuer","find","a","shortName","value","map","recipient","keyId","findKeyById","missingKeys","join","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nrequire('node-forge/lib/pkcs7')\nrequire('node-forge/lib/pbe')\nconst forge = require('node-forge/lib/forge')\nconst { certificateForKey, findAsync } = require('./util')\nconst errcode = require('err-code')\n\n/**\n * Cryptographic Message Syntax (aka PKCS #7)\n *\n * CMS describes an encapsulation syntax for data protection. It\n * is used to digitally sign, digest, authenticate, or encrypt\n * arbitrary message content.\n *\n * See RFC 5652 for all the details.\n */\nclass CMS {\n  /**\n   * Creates a new instance with a keychain\n   *\n   * @param {Keychain} keychain - the available keys\n   */\n  constructor (keychain) {\n    if (!keychain) {\n      throw errcode(new Error('keychain is required'), 'ERR_KEYCHAIN_REQUIRED')\n    }\n\n    this.keychain = keychain\n  }\n\n  /**\n   * Creates some protected data.\n   *\n   * The output Buffer contains the PKCS #7 message in DER.\n   *\n   * @param {string} name - The local key name.\n   * @param {Buffer} plain - The data to encrypt.\n   * @returns {undefined}\n   */\n  async encrypt (name, plain) {\n    if (!Buffer.isBuffer(plain)) {\n      throw errcode(new Error('Plain data must be a Buffer'), 'ERR_INVALID_PARAMS')\n    }\n\n    const key = await this.keychain.findKeyByName(name)\n    const pem = await this.keychain._getPrivateKey(name)\n    const privateKey = forge.pki.decryptRsaPrivateKey(pem, this.keychain._())\n    const certificate = await certificateForKey(key, privateKey)\n\n    // create a p7 enveloped message\n    const p7 = forge.pkcs7.createEnvelopedData()\n    p7.addRecipient(certificate)\n    p7.content = forge.util.createBuffer(plain)\n    p7.encrypt()\n\n    // convert message to DER\n    const der = forge.asn1.toDer(p7.toAsn1()).getBytes()\n    return Buffer.from(der, 'binary')\n  }\n\n  /**\n   * Reads some protected data.\n   *\n   * The keychain must contain one of the keys used to encrypt the data.  If none of the keys\n   * exists, an Error is returned with the property 'missingKeys'.  It is array of key ids.\n   *\n   * @param {Buffer} cmsData - The CMS encrypted data to decrypt.\n   * @returns {undefined}\n   */\n  async decrypt (cmsData) {\n    if (!Buffer.isBuffer(cmsData)) {\n      throw errcode(new Error('CMS data is required'), 'ERR_INVALID_PARAMS')\n    }\n\n    let cms\n    try {\n      const buf = forge.util.createBuffer(cmsData.toString('binary'))\n      const obj = forge.asn1.fromDer(buf)\n      cms = forge.pkcs7.messageFromAsn1(obj)\n    } catch (err) {\n      throw errcode(new Error('Invalid CMS: ' + err.message), 'ERR_INVALID_CMS')\n    }\n\n    // Find a recipient whose key we hold. We only deal with recipient certs\n    // issued by ipfs (O=ipfs).\n    const recipients = cms.recipients\n      .filter(r => r.issuer.find(a => a.shortName === 'O' && a.value === 'ipfs'))\n      .filter(r => r.issuer.find(a => a.shortName === 'CN'))\n      .map(r => {\n        return {\n          recipient: r,\n          keyId: r.issuer.find(a => a.shortName === 'CN').value\n        }\n      })\n\n    const r = await findAsync(recipients, async (recipient) => {\n      try {\n        const key = await this.keychain.findKeyById(recipient.keyId)\n        if (key) return true\n      } catch (err) {\n        return false\n      }\n      return false\n    })\n\n    if (!r) {\n      const missingKeys = recipients.map(r => r.keyId)\n      throw errcode(new Error('Decryption needs one of the key(s): ' + missingKeys.join(', ')), 'ERR_MISSING_KEYS', {\n        missingKeys\n      })\n    }\n\n    const key = await this.keychain.findKeyById(r.keyId)\n    const pem = await this.keychain._getPrivateKey(key.name)\n    const privateKey = forge.pki.decryptRsaPrivateKey(pem, this.keychain._())\n    cms.decrypt(r.recipient, privateKey)\n    return Buffer.from(cms.content.getBytes(), 'binary')\n  }\n}\n\nmodule.exports = CMS\n"]},"metadata":{},"sourceType":"script"}