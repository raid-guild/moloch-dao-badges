{"ast":null,"code":"'use strict';\n\nconst multiaddr = require('multiaddr');\n\nfunction cleanUrlSIO(ma) {\n  const maStrSplit = ma.toString().split('/');\n  const tcpProto = ma.protos()[1].name;\n  const wsProto = ma.protos()[2].name;\n  const tcpPort = ma.stringTuples()[1][1];\n\n  if (tcpProto !== 'tcp' || wsProto !== 'ws' && wsProto !== 'wss') {\n    throw new Error('invalid multiaddr: ' + ma.toString());\n  }\n\n  if (!multiaddr.isName(ma)) {\n    return 'http://' + maStrSplit[2] + ':' + maStrSplit[4];\n  }\n\n  if (wsProto === 'ws') {\n    return 'http://' + maStrSplit[2] + (tcpPort === 80 ? '' : ':' + tcpPort);\n  }\n\n  if (wsProto === 'wss') {\n    return 'https://' + maStrSplit[2] + (tcpPort === 443 ? '' : ':' + tcpPort);\n  }\n}\n\nfunction cleanMultiaddr(maStr) {\n  const legacy = '/libp2p-webrtc-star';\n\n  if (maStr.indexOf(legacy) !== -1) {\n    maStr = maStr.substring(legacy.length, maStr.length);\n    let ma = multiaddr(maStr);\n    const tuppleIPFS = ma.stringTuples().filter(tupple => {\n      return tupple[0] === 421; // ipfs code\n    })[0];\n    ma = ma.decapsulate('ipfs');\n    ma = ma.encapsulate('/p2p-webrtc-star');\n    ma = ma.encapsulate(`/ipfs/${tuppleIPFS[1]}`);\n    maStr = ma.toString();\n  }\n\n  return maStr;\n}\n\nexports = module.exports;\nexports.cleanUrlSIO = cleanUrlSIO;\nexports.cleanMultiaddr = cleanMultiaddr;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-webrtc-star/src/utils.js"],"names":["multiaddr","require","cleanUrlSIO","ma","maStrSplit","toString","split","tcpProto","protos","name","wsProto","tcpPort","stringTuples","Error","isName","cleanMultiaddr","maStr","legacy","indexOf","substring","length","tuppleIPFS","filter","tupple","decapsulate","encapsulate","exports","module"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAzB;;AAEA,SAASC,WAAT,CAAsBC,EAAtB,EAA0B;AACxB,QAAMC,UAAU,GAAGD,EAAE,CAACE,QAAH,GAAcC,KAAd,CAAoB,GAApB,CAAnB;AACA,QAAMC,QAAQ,GAAGJ,EAAE,CAACK,MAAH,GAAY,CAAZ,EAAeC,IAAhC;AACA,QAAMC,OAAO,GAAGP,EAAE,CAACK,MAAH,GAAY,CAAZ,EAAeC,IAA/B;AACA,QAAME,OAAO,GAAGR,EAAE,CAACS,YAAH,GAAkB,CAAlB,EAAqB,CAArB,CAAhB;;AAEA,MAAIL,QAAQ,KAAK,KAAb,IAAuBG,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAA3D,EAAmE;AACjE,UAAM,IAAIG,KAAJ,CAAU,wBAAwBV,EAAE,CAACE,QAAH,EAAlC,CAAN;AACD;;AAED,MAAI,CAACL,SAAS,CAACc,MAAV,CAAiBX,EAAjB,CAAL,EAA2B;AACzB,WAAO,YAAYC,UAAU,CAAC,CAAD,CAAtB,GAA4B,GAA5B,GAAkCA,UAAU,CAAC,CAAD,CAAnD;AACD;;AAED,MAAIM,OAAO,KAAK,IAAhB,EAAsB;AACpB,WAAO,YAAYN,UAAU,CAAC,CAAD,CAAtB,IAA6BO,OAAO,KAAK,EAAZ,GAAiB,EAAjB,GAAsB,MAAMA,OAAzD,CAAP;AACD;;AAED,MAAID,OAAO,KAAK,KAAhB,EAAuB;AACrB,WAAO,aAAaN,UAAU,CAAC,CAAD,CAAvB,IAA8BO,OAAO,KAAK,GAAZ,GAAkB,EAAlB,GAAuB,MAAMA,OAA3D,CAAP;AACD;AACF;;AAED,SAASI,cAAT,CAAyBC,KAAzB,EAAgC;AAC9B,QAAMC,MAAM,GAAG,qBAAf;;AAEA,MAAID,KAAK,CAACE,OAAN,CAAcD,MAAd,MAA0B,CAAC,CAA/B,EAAkC;AAChCD,IAAAA,KAAK,GAAGA,KAAK,CAACG,SAAN,CAAgBF,MAAM,CAACG,MAAvB,EAA+BJ,KAAK,CAACI,MAArC,CAAR;AACA,QAAIjB,EAAE,GAAGH,SAAS,CAACgB,KAAD,CAAlB;AACA,UAAMK,UAAU,GAAGlB,EAAE,CAACS,YAAH,GAAkBU,MAAlB,CAA0BC,MAAD,IAAY;AACtD,aAAOA,MAAM,CAAC,CAAD,CAAN,KAAc,GAArB,CADsD,CAC7B;AAC1B,KAFkB,EAEhB,CAFgB,CAAnB;AAIApB,IAAAA,EAAE,GAAGA,EAAE,CAACqB,WAAH,CAAe,MAAf,CAAL;AACArB,IAAAA,EAAE,GAAGA,EAAE,CAACsB,WAAH,CAAe,kBAAf,CAAL;AACAtB,IAAAA,EAAE,GAAGA,EAAE,CAACsB,WAAH,CAAgB,SAAQJ,UAAU,CAAC,CAAD,CAAI,EAAtC,CAAL;AACAL,IAAAA,KAAK,GAAGb,EAAE,CAACE,QAAH,EAAR;AACD;;AAED,SAAOW,KAAP;AACD;;AAEDU,OAAO,GAAGC,MAAM,CAACD,OAAjB;AACAA,OAAO,CAACxB,WAAR,GAAsBA,WAAtB;AACAwB,OAAO,CAACX,cAAR,GAAyBA,cAAzB","sourcesContent":["'use strict'\n\nconst multiaddr = require('multiaddr')\n\nfunction cleanUrlSIO (ma) {\n  const maStrSplit = ma.toString().split('/')\n  const tcpProto = ma.protos()[1].name\n  const wsProto = ma.protos()[2].name\n  const tcpPort = ma.stringTuples()[1][1]\n\n  if (tcpProto !== 'tcp' || (wsProto !== 'ws' && wsProto !== 'wss')) {\n    throw new Error('invalid multiaddr: ' + ma.toString())\n  }\n\n  if (!multiaddr.isName(ma)) {\n    return 'http://' + maStrSplit[2] + ':' + maStrSplit[4]\n  }\n\n  if (wsProto === 'ws') {\n    return 'http://' + maStrSplit[2] + (tcpPort === 80 ? '' : ':' + tcpPort)\n  }\n\n  if (wsProto === 'wss') {\n    return 'https://' + maStrSplit[2] + (tcpPort === 443 ? '' : ':' + tcpPort)\n  }\n}\n\nfunction cleanMultiaddr (maStr) {\n  const legacy = '/libp2p-webrtc-star'\n\n  if (maStr.indexOf(legacy) !== -1) {\n    maStr = maStr.substring(legacy.length, maStr.length)\n    let ma = multiaddr(maStr)\n    const tuppleIPFS = ma.stringTuples().filter((tupple) => {\n      return tupple[0] === 421 // ipfs code\n    })[0]\n\n    ma = ma.decapsulate('ipfs')\n    ma = ma.encapsulate('/p2p-webrtc-star')\n    ma = ma.encapsulate(`/ipfs/${tuppleIPFS[1]}`)\n    maStr = ma.toString()\n  }\n\n  return maStr\n}\n\nexports = module.exports\nexports.cleanUrlSIO = cleanUrlSIO\nexports.cleanMultiaddr = cleanMultiaddr\n"]},"metadata":{},"sourceType":"script"}