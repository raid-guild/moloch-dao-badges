{"ast":null,"code":"'use strict';\n\nconst BufferList = require('bl');\n\nconst {\n  create\n} = require('rabin-wasm');\n\nconst errcode = require('err-code');\n\nmodule.exports = async function* rabinChunker(source, options) {\n  const rabin = jsRabin();\n  let min, max, avg;\n\n  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {\n    avg = options.avgChunkSize;\n    min = options.minChunkSize;\n    max = options.maxChunkSize;\n  } else if (!options.avgChunkSize) {\n    throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE');\n  } else {\n    avg = options.avgChunkSize;\n    min = avg / 3;\n    max = avg + avg / 2;\n  } // validate min/max/avg in the same way as go\n\n\n  if (min < 16) {\n    throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE');\n  }\n\n  if (max < min) {\n    max = min;\n  }\n\n  if (avg < min) {\n    avg = min;\n  }\n\n  const sizepow = Math.floor(Math.log2(avg));\n\n  for await (const chunk of rabin(source, {\n    min: min,\n    max: max,\n    bits: sizepow,\n    window: options.window,\n    polynomial: options.polynomial\n  })) {\n    yield chunk;\n  }\n};\n\nconst jsRabin = () => {\n  return async function* (source, options) {\n    const r = await create(options.bits, options.min, options.max, options.window);\n    const buffers = new BufferList();\n    let pending = [];\n\n    for await (const chunk of source) {\n      buffers.append(chunk);\n      pending.push(chunk);\n      const sizes = r.fingerprint(Buffer.concat(pending));\n      pending = [];\n\n      for (let i = 0; i < sizes.length; i++) {\n        var size = sizes[i];\n        var buf = buffers.slice(0, size);\n        buffers.consume(size);\n        yield buf;\n      }\n    }\n\n    if (buffers.length) {\n      yield buffers.slice(0);\n    }\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-unixfs-importer/src/chunker/rabin.js"],"names":["BufferList","require","create","errcode","module","exports","rabinChunker","source","options","rabin","jsRabin","min","max","avg","minChunkSize","maxChunkSize","avgChunkSize","Error","sizepow","Math","floor","log2","chunk","bits","window","polynomial","r","buffers","pending","append","push","sizes","fingerprint","Buffer","concat","i","length","size","buf","slice","consume"],"mappings":"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","sourcesContent":["'use strict'\n\nconst BufferList = require('bl')\nconst { create } = require('rabin-wasm')\nconst errcode = require('err-code')\n\nmodule.exports = async function * rabinChunker (source, options) {\n  const rabin = jsRabin()\n\n  let min, max, avg\n\n  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {\n    avg = options.avgChunkSize\n    min = options.minChunkSize\n    max = options.maxChunkSize\n  } else if (!options.avgChunkSize) {\n    throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE')\n  } else {\n    avg = options.avgChunkSize\n    min = avg / 3\n    max = avg + (avg / 2)\n  }\n\n  // validate min/max/avg in the same way as go\n  if (min < 16) {\n    throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE')\n  }\n\n  if (max < min) {\n    max = min\n  }\n\n  if (avg < min) {\n    avg = min\n  }\n\n  const sizepow = Math.floor(Math.log2(avg))\n\n  for await (const chunk of rabin(source, {\n    min: min,\n    max: max,\n    bits: sizepow,\n    window: options.window,\n    polynomial: options.polynomial\n  })) {\n    yield chunk\n  }\n}\n\nconst jsRabin = () => {\n  return async function * (source, options) {\n    const r = await create(options.bits, options.min, options.max, options.window)\n    const buffers = new BufferList()\n    let pending = []\n\n    for await (const chunk of source) {\n      buffers.append(chunk)\n      pending.push(chunk)\n\n      const sizes = r.fingerprint(Buffer.concat(pending))\n      pending = []\n\n      for (let i = 0; i < sizes.length; i++) {\n        var size = sizes[i]\n        var buf = buffers.slice(0, size)\n        buffers.consume(size)\n\n        yield buf\n      }\n    }\n\n    if (buffers.length) {\n      yield buffers.slice(0)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}