{"ast":null,"code":"'use strict';\n\nmodule.exports = (iterable, mapper, opts) => new Promise((resolve, reject) => {\n  opts = Object.assign({\n    concurrency: Infinity\n  }, opts);\n\n  if (typeof mapper !== 'function') {\n    throw new TypeError('Mapper function is required');\n  }\n\n  const concurrency = opts.concurrency;\n\n  if (!(typeof concurrency === 'number' && concurrency >= 1)) {\n    throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${concurrency}\\` (${typeof concurrency})`);\n  }\n\n  const ret = [];\n  const iterator = iterable[Symbol.iterator]();\n  let isRejected = false;\n  let iterableDone = false;\n  let resolvingCount = 0;\n  let currentIdx = 0;\n\n  const next = () => {\n    if (isRejected) {\n      return;\n    }\n\n    const nextItem = iterator.next();\n    const i = currentIdx;\n    currentIdx++;\n\n    if (nextItem.done) {\n      iterableDone = true;\n\n      if (resolvingCount === 0) {\n        resolve(ret);\n      }\n\n      return;\n    }\n\n    resolvingCount++;\n    Promise.resolve(nextItem.value).then(el => mapper(el, i)).then(val => {\n      ret[i] = val;\n      resolvingCount--;\n      next();\n    }, err => {\n      isRejected = true;\n      reject(err);\n    });\n  };\n\n  for (let i = 0; i < concurrency; i++) {\n    next();\n\n    if (iterableDone) {\n      break;\n    }\n  }\n});","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs-log/node_modules/p-map/index.js"],"names":["module","exports","iterable","mapper","opts","Promise","resolve","reject","Object","assign","concurrency","Infinity","TypeError","ret","iterator","Symbol","isRejected","iterableDone","resolvingCount","currentIdx","next","nextItem","i","done","value","then","el","val","err"],"mappings":"AAAA;;AACAA,MAAM,CAACC,OAAP,GAAiB,CAACC,QAAD,EAAWC,MAAX,EAAmBC,IAAnB,KAA4B,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC7EH,EAAAA,IAAI,GAAGI,MAAM,CAACC,MAAP,CAAc;AACpBC,IAAAA,WAAW,EAAEC;AADO,GAAd,EAEJP,IAFI,CAAP;;AAIA,MAAI,OAAOD,MAAP,KAAkB,UAAtB,EAAkC;AACjC,UAAM,IAAIS,SAAJ,CAAc,6BAAd,CAAN;AACA;;AAED,QAAMF,WAAW,GAAGN,IAAI,CAACM,WAAzB;;AAEA,MAAI,EAAE,OAAOA,WAAP,KAAuB,QAAvB,IAAmCA,WAAW,IAAI,CAApD,CAAJ,EAA4D;AAC3D,UAAM,IAAIE,SAAJ,CAAe,gEAA+DF,WAAY,OAAM,OAAOA,WAAY,GAAnH,CAAN;AACA;;AAED,QAAMG,GAAG,GAAG,EAAZ;AACA,QAAMC,QAAQ,GAAGZ,QAAQ,CAACa,MAAM,CAACD,QAAR,CAAR,EAAjB;AACA,MAAIE,UAAU,GAAG,KAAjB;AACA,MAAIC,YAAY,GAAG,KAAnB;AACA,MAAIC,cAAc,GAAG,CAArB;AACA,MAAIC,UAAU,GAAG,CAAjB;;AAEA,QAAMC,IAAI,GAAG,MAAM;AAClB,QAAIJ,UAAJ,EAAgB;AACf;AACA;;AAED,UAAMK,QAAQ,GAAGP,QAAQ,CAACM,IAAT,EAAjB;AACA,UAAME,CAAC,GAAGH,UAAV;AACAA,IAAAA,UAAU;;AAEV,QAAIE,QAAQ,CAACE,IAAb,EAAmB;AAClBN,MAAAA,YAAY,GAAG,IAAf;;AAEA,UAAIC,cAAc,KAAK,CAAvB,EAA0B;AACzBZ,QAAAA,OAAO,CAACO,GAAD,CAAP;AACA;;AAED;AACA;;AAEDK,IAAAA,cAAc;AAEdb,IAAAA,OAAO,CAACC,OAAR,CAAgBe,QAAQ,CAACG,KAAzB,EACEC,IADF,CACOC,EAAE,IAAIvB,MAAM,CAACuB,EAAD,EAAKJ,CAAL,CADnB,EAEEG,IAFF,CAGEE,GAAG,IAAI;AACNd,MAAAA,GAAG,CAACS,CAAD,CAAH,GAASK,GAAT;AACAT,MAAAA,cAAc;AACdE,MAAAA,IAAI;AACJ,KAPH,EAQEQ,GAAG,IAAI;AACNZ,MAAAA,UAAU,GAAG,IAAb;AACAT,MAAAA,MAAM,CAACqB,GAAD,CAAN;AACA,KAXH;AAaA,GAlCD;;AAoCA,OAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,WAApB,EAAiCY,CAAC,EAAlC,EAAsC;AACrCF,IAAAA,IAAI;;AAEJ,QAAIH,YAAJ,EAAkB;AACjB;AACA;AACD;AACD,CAjE4C,CAA7C","sourcesContent":["'use strict';\nmodule.exports = (iterable, mapper, opts) => new Promise((resolve, reject) => {\n\topts = Object.assign({\n\t\tconcurrency: Infinity\n\t}, opts);\n\n\tif (typeof mapper !== 'function') {\n\t\tthrow new TypeError('Mapper function is required');\n\t}\n\n\tconst concurrency = opts.concurrency;\n\n\tif (!(typeof concurrency === 'number' && concurrency >= 1)) {\n\t\tthrow new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t}\n\n\tconst ret = [];\n\tconst iterator = iterable[Symbol.iterator]();\n\tlet isRejected = false;\n\tlet iterableDone = false;\n\tlet resolvingCount = 0;\n\tlet currentIdx = 0;\n\n\tconst next = () => {\n\t\tif (isRejected) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nextItem = iterator.next();\n\t\tconst i = currentIdx;\n\t\tcurrentIdx++;\n\n\t\tif (nextItem.done) {\n\t\t\titerableDone = true;\n\n\t\t\tif (resolvingCount === 0) {\n\t\t\t\tresolve(ret);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tresolvingCount++;\n\n\t\tPromise.resolve(nextItem.value)\n\t\t\t.then(el => mapper(el, i))\n\t\t\t.then(\n\t\t\t\tval => {\n\t\t\t\t\tret[i] = val;\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t},\n\t\t\t\terr => {\n\t\t\t\t\tisRejected = true;\n\t\t\t\t\treject(err);\n\t\t\t\t}\n\t\t\t);\n\t};\n\n\tfor (let i = 0; i < concurrency; i++) {\n\t\tnext();\n\n\t\tif (iterableDone) {\n\t\t\tbreak;\n\t\t}\n\t}\n});\n"]},"metadata":{},"sourceType":"script"}