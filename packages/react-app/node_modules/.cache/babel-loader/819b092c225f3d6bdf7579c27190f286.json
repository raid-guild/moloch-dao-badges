{"ast":null,"code":"'use strict';\n\nconst protons = require('protons');\n\nconst proto = protons(require('./dag.proto.js'));\n\nconst DAGLink = require('./dag-link/dagLink');\n\nexports = module.exports;\n\nconst toProtoBuf = node => {\n  const pbn = {};\n\n  if (node.Data && node.Data.length > 0) {\n    pbn.Data = node.Data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization\n    // `null !== new Buffer(0)`\n    pbn.Data = null;\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links.map(link => ({\n      Hash: link.Hash.buffer,\n      Name: link.Name,\n      Tsize: link.Tsize\n    }));\n  } else {\n    pbn.Links = null;\n  }\n\n  return pbn;\n};\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a PB block\n * @returns {Buffer} - The encoded binary representation\n */\n\n\nconst serializeDAGNode = node => {\n  const data = node.Data;\n  const links = node.Links || [];\n  const serialized = proto.PBNode.encode(toProtoBuf({\n    Data: data,\n    Links: links\n  }));\n  return serialized;\n}; // Serialize an object where the `Links` might not be a `DAGLink` instance yet\n\n\nconst serializeDAGNodeLike = (data, links = []) => {\n  const node = {\n    Data: data\n  };\n  node.Links = links.map(link => {\n    return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);\n  });\n  return serializeDAGNode(node);\n};\n\nexports.serializeDAGNode = serializeDAGNode;\nexports.serializeDAGNodeLike = serializeDAGNodeLike;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipld-dag-pb/src/serialize.js"],"names":["protons","require","proto","DAGLink","exports","module","toProtoBuf","node","pbn","Data","length","Links","map","link","Hash","buffer","Name","Tsize","serializeDAGNode","data","links","serialized","PBNode","encode","serializeDAGNodeLike","isDAGLink","util","createDagLinkFromB58EncodedHash"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMC,KAAK,GAAGF,OAAO,CAACC,OAAO,CAAC,gBAAD,CAAR,CAArB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,oBAAD,CAAvB;;AAEAG,OAAO,GAAGC,MAAM,CAACD,OAAjB;;AAEA,MAAME,UAAU,GAAIC,IAAD,IAAU;AAC3B,QAAMC,GAAG,GAAG,EAAZ;;AAEA,MAAID,IAAI,CAACE,IAAL,IAAaF,IAAI,CAACE,IAAL,CAAUC,MAAV,GAAmB,CAApC,EAAuC;AACrCF,IAAAA,GAAG,CAACC,IAAJ,GAAWF,IAAI,CAACE,IAAhB;AACD,GAFD,MAEO;AACL;AACA;AACAD,IAAAA,GAAG,CAACC,IAAJ,GAAW,IAAX;AACD;;AAED,MAAIF,IAAI,CAACI,KAAL,IAAcJ,IAAI,CAACI,KAAL,CAAWD,MAAX,GAAoB,CAAtC,EAAyC;AACvCF,IAAAA,GAAG,CAACG,KAAJ,GAAYJ,IAAI,CAACI,KAAL,CACTC,GADS,CACJC,IAAD,KAAW;AACdC,MAAAA,IAAI,EAAED,IAAI,CAACC,IAAL,CAAUC,MADF;AAEdC,MAAAA,IAAI,EAAEH,IAAI,CAACG,IAFG;AAGdC,MAAAA,KAAK,EAAEJ,IAAI,CAACI;AAHE,KAAX,CADK,CAAZ;AAMD,GAPD,MAOO;AACLT,IAAAA,GAAG,CAACG,KAAJ,GAAY,IAAZ;AACD;;AAED,SAAOH,GAAP;AACD,CAvBD;AAyBA;;;;;;;;AAMA,MAAMU,gBAAgB,GAAIX,IAAD,IAAU;AACjC,QAAMY,IAAI,GAAGZ,IAAI,CAACE,IAAlB;AACA,QAAMW,KAAK,GAAGb,IAAI,CAACI,KAAL,IAAc,EAA5B;AAEA,QAAMU,UAAU,GAAGnB,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoBjB,UAAU,CAAC;AAChDG,IAAAA,IAAI,EAAEU,IAD0C;AAEhDR,IAAAA,KAAK,EAAES;AAFyC,GAAD,CAA9B,CAAnB;AAKA,SAAOC,UAAP;AACD,CAVD,C,CAYA;;;AACA,MAAMG,oBAAoB,GAAG,CAACL,IAAD,EAAOC,KAAK,GAAG,EAAf,KAAsB;AACjD,QAAMb,IAAI,GAAG;AAAEE,IAAAA,IAAI,EAAEU;AAAR,GAAb;AACAZ,EAAAA,IAAI,CAACI,KAAL,GAAaS,KAAK,CAACR,GAAN,CAAWC,IAAD,IAAU;AAC/B,WAAOV,OAAO,CAACsB,SAAR,CAAkBZ,IAAlB,IACHA,IADG,GAEHV,OAAO,CAACuB,IAAR,CAAaC,+BAAb,CAA6Cd,IAA7C,CAFJ;AAGD,GAJY,CAAb;AAKA,SAAOK,gBAAgB,CAACX,IAAD,CAAvB;AACD,CARD;;AAUAH,OAAO,CAACc,gBAAR,GAA2BA,gBAA3B;AACAd,OAAO,CAACoB,oBAAR,GAA+BA,oBAA/B","sourcesContent":["'use strict'\n\nconst protons = require('protons')\nconst proto = protons(require('./dag.proto.js'))\nconst DAGLink = require('./dag-link/dagLink')\n\nexports = module.exports\n\nconst toProtoBuf = (node) => {\n  const pbn = {}\n\n  if (node.Data && node.Data.length > 0) {\n    pbn.Data = node.Data\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization\n    // `null !== new Buffer(0)`\n    pbn.Data = null\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links\n      .map((link) => ({\n        Hash: link.Hash.buffer,\n        Name: link.Name,\n        Tsize: link.Tsize\n      }))\n  } else {\n    pbn.Links = null\n  }\n\n  return pbn\n}\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a PB block\n * @returns {Buffer} - The encoded binary representation\n */\nconst serializeDAGNode = (node) => {\n  const data = node.Data\n  const links = node.Links || []\n\n  const serialized = proto.PBNode.encode(toProtoBuf({\n    Data: data,\n    Links: links\n  }))\n\n  return serialized\n}\n\n// Serialize an object where the `Links` might not be a `DAGLink` instance yet\nconst serializeDAGNodeLike = (data, links = []) => {\n  const node = { Data: data }\n  node.Links = links.map((link) => {\n    return DAGLink.isDAGLink(link)\n      ? link\n      : DAGLink.util.createDagLinkFromB58EncodedHash(link)\n  })\n  return serializeDAGNode(node)\n}\n\nexports.serializeDAGNode = serializeDAGNode\nexports.serializeDAGNodeLike = serializeDAGNodeLike\n"]},"metadata":{},"sourceType":"script"}