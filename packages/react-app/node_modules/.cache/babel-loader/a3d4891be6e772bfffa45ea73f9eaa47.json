{"ast":null,"code":"'use strict';\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create('cache', {\n  color: Logger.Colors.Magenta\n});\nLogger.setLogLevel('ERROR');\n\nclass Cache {\n  constructor(store) {\n    this._store = store;\n  }\n\n  get status() {\n    return this._store.db.status;\n  }\n\n  async close() {\n    if (!this._store) return Promise.reject(new Error('No cache store found to close'));\n\n    if (this.status === 'open') {\n      await this._store.close();\n      return Promise.resolve();\n    }\n  }\n\n  async open() {\n    if (!this._store) return Promise.reject(new Error('No cache store found to open'));\n\n    if (this.status !== 'open') {\n      await this._store.open();\n      return Promise.resolve();\n    }\n  }\n\n  async get(key) {\n    return new Promise((resolve, reject) => {\n      this._store.get(key, (err, value) => {\n        if (err) {\n          // Ignore error if key was not found\n          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 && err.toString().indexOf('NotFound') === -1) {\n            return reject(err);\n          }\n        }\n\n        resolve(value ? JSON.parse(value) : null);\n      });\n    });\n  } // Set value in the cache and return the new value\n\n\n  set(key, value) {\n    return new Promise((resolve, reject) => {\n      this._store.put(key, JSON.stringify(value), err => {\n        if (err) {\n          // Ignore error if key was not found\n          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 && err.toString().indexOf('NotFound') === -1) {\n            return reject(err);\n          }\n        }\n\n        logger.debug(`cache: Set ${key} to ${value}`);\n        resolve();\n      });\n    });\n  }\n\n  load() {} // noop\n\n\n  destroy() {} // noop\n  // Remove a value and key from the cache\n\n\n  async del(key) {\n    return new Promise((resolve, reject) => {\n      this._store.del(key, err => {\n        if (err) {\n          // Ignore error if key was not found\n          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 && err.toString().indexOf('NotFound') === -1) {\n            return reject(err);\n          }\n        }\n\n        resolve();\n      });\n    });\n  }\n\n}\n\nmodule.exports = Cache;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/orbit-db-cache/src/Cache.js"],"names":["Logger","require","logger","create","color","Colors","Magenta","setLogLevel","Cache","constructor","store","_store","status","db","close","Promise","reject","Error","resolve","open","get","key","err","value","toString","indexOf","JSON","parse","set","put","stringify","debug","load","destroy","del","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGF,MAAM,CAACG,MAAP,CAAc,OAAd,EAAuB;AAAEC,EAAAA,KAAK,EAAEJ,MAAM,CAACK,MAAP,CAAcC;AAAvB,CAAvB,CAAf;AACAN,MAAM,CAACO,WAAP,CAAmB,OAAnB;;AAEA,MAAMC,KAAN,CAAY;AACVC,EAAAA,WAAW,CAAEC,KAAF,EAAS;AAClB,SAAKC,MAAL,GAAcD,KAAd;AACD;;AAED,MAAIE,MAAJ,GAAc;AAAE,WAAO,KAAKD,MAAL,CAAYE,EAAZ,CAAeD,MAAtB;AAA8B;;AAE9C,QAAME,KAAN,GAAe;AACb,QAAI,CAAC,KAAKH,MAAV,EAAkB,OAAOI,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAU,+BAAV,CAAf,CAAP;;AAClB,QAAI,KAAKL,MAAL,KAAgB,MAApB,EAA4B;AAC1B,YAAM,KAAKD,MAAL,CAAYG,KAAZ,EAAN;AACA,aAAOC,OAAO,CAACG,OAAR,EAAP;AACD;AACF;;AAED,QAAMC,IAAN,GAAc;AACZ,QAAI,CAAC,KAAKR,MAAV,EAAkB,OAAOI,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAU,8BAAV,CAAf,CAAP;;AAClB,QAAI,KAAKL,MAAL,KAAgB,MAApB,EAA4B;AAC1B,YAAM,KAAKD,MAAL,CAAYQ,IAAZ,EAAN;AACA,aAAOJ,OAAO,CAACG,OAAR,EAAP;AACD;AACF;;AAED,QAAME,GAAN,CAAWC,GAAX,EAAgB;AACd,WAAO,IAAIN,OAAJ,CAAY,CAACG,OAAD,EAAUF,MAAV,KAAqB;AACtC,WAAKL,MAAL,CAAYS,GAAZ,CAAgBC,GAAhB,EAAqB,CAACC,GAAD,EAAMC,KAAN,KAAgB;AACnC,YAAID,GAAJ,EAAS;AACP;AACA,cAAIA,GAAG,CAACE,QAAJ,GAAeC,OAAf,CAAuB,0CAAvB,MAAuE,CAAC,CAAxE,IACFH,GAAG,CAACE,QAAJ,GAAeC,OAAf,CAAuB,UAAvB,MAAuC,CAAC,CAD1C,EAC6C;AAC3C,mBAAOT,MAAM,CAACM,GAAD,CAAb;AACD;AACF;;AACDJ,QAAAA,OAAO,CAACK,KAAK,GAAGG,IAAI,CAACC,KAAL,CAAWJ,KAAX,CAAH,GAAuB,IAA7B,CAAP;AACD,OATD;AAUD,KAXM,CAAP;AAYD,GApCS,CAsCV;;;AACAK,EAAAA,GAAG,CAAEP,GAAF,EAAOE,KAAP,EAAc;AACf,WAAO,IAAIR,OAAJ,CAAY,CAACG,OAAD,EAAUF,MAAV,KAAqB;AACtC,WAAKL,MAAL,CAAYkB,GAAZ,CAAgBR,GAAhB,EAAqBK,IAAI,CAACI,SAAL,CAAeP,KAAf,CAArB,EAA6CD,GAAD,IAAS;AACnD,YAAIA,GAAJ,EAAS;AACP;AACA,cAAIA,GAAG,CAACE,QAAJ,GAAeC,OAAf,CAAuB,0CAAvB,MAAuE,CAAC,CAAxE,IACFH,GAAG,CAACE,QAAJ,GAAeC,OAAf,CAAuB,UAAvB,MAAuC,CAAC,CAD1C,EAC6C;AAC3C,mBAAOT,MAAM,CAACM,GAAD,CAAb;AACD;AACF;;AACDpB,QAAAA,MAAM,CAAC6B,KAAP,CAAc,cAAaV,GAAI,OAAME,KAAM,EAA3C;AACAL,QAAAA,OAAO;AACR,OAVD;AAWD,KAZM,CAAP;AAaD;;AAEDc,EAAAA,IAAI,GAAI,CAAE,CAvDA,CAuDC;;;AACXC,EAAAA,OAAO,GAAI,CAAG,CAxDJ,CAwDK;AAEf;;;AACA,QAAMC,GAAN,CAAWb,GAAX,EAAgB;AACd,WAAO,IAAIN,OAAJ,CAAY,CAACG,OAAD,EAAUF,MAAV,KAAqB;AACtC,WAAKL,MAAL,CAAYuB,GAAZ,CAAgBb,GAAhB,EAAsBC,GAAD,IAAS;AAC5B,YAAIA,GAAJ,EAAS;AACP;AACA,cAAIA,GAAG,CAACE,QAAJ,GAAeC,OAAf,CAAuB,0CAAvB,MAAuE,CAAC,CAAxE,IACFH,GAAG,CAACE,QAAJ,GAAeC,OAAf,CAAuB,UAAvB,MAAuC,CAAC,CAD1C,EAC6C;AAC3C,mBAAOT,MAAM,CAACM,GAAD,CAAb;AACD;AACF;;AACDJ,QAAAA,OAAO;AACR,OATD;AAUD,KAXM,CAAP;AAYD;;AAxES;;AA2EZiB,MAAM,CAACC,OAAP,GAAiB5B,KAAjB","sourcesContent":["'use strict'\n\nconst Logger = require('logplease')\nconst logger = Logger.create('cache', { color: Logger.Colors.Magenta })\nLogger.setLogLevel('ERROR')\n\nclass Cache {\n  constructor (store) {\n    this._store = store\n  }\n\n  get status () { return this._store.db.status }\n\n  async close () {\n    if (!this._store) return Promise.reject(new Error('No cache store found to close'))\n    if (this.status === 'open') {\n      await this._store.close()\n      return Promise.resolve()\n    }\n  }\n\n  async open () {\n    if (!this._store) return Promise.reject(new Error('No cache store found to open'))\n    if (this.status !== 'open') {\n      await this._store.open()\n      return Promise.resolve()\n    }\n  }\n\n  async get (key) {\n    return new Promise((resolve, reject) => {\n      this._store.get(key, (err, value) => {\n        if (err) {\n          // Ignore error if key was not found\n          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 &&\n            err.toString().indexOf('NotFound') === -1) {\n            return reject(err)\n          }\n        }\n        resolve(value ? JSON.parse(value) : null)\n      })\n    })\n  }\n\n  // Set value in the cache and return the new value\n  set (key, value) {\n    return new Promise((resolve, reject) => {\n      this._store.put(key, JSON.stringify(value), (err) => {\n        if (err) {\n          // Ignore error if key was not found\n          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 &&\n            err.toString().indexOf('NotFound') === -1) {\n            return reject(err)\n          }\n        }\n        logger.debug(`cache: Set ${key} to ${value}`)\n        resolve()\n      })\n    })\n  }\n\n  load () {} // noop\n  destroy () { } // noop\n\n  // Remove a value and key from the cache\n  async del (key) {\n    return new Promise((resolve, reject) => {\n      this._store.del(key, (err) => {\n        if (err) {\n          // Ignore error if key was not found\n          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 &&\n            err.toString().indexOf('NotFound') === -1) {\n            return reject(err)\n          }\n        }\n        resolve()\n      })\n    })\n  }\n}\n\nmodule.exports = Cache\n"]},"metadata":{},"sourceType":"script"}