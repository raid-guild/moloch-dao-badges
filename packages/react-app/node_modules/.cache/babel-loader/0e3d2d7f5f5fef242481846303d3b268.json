{"ast":null,"code":"'use strict';\n\nconst SparseArray = require('sparse-array');\n\nconst wrapHash = require('./consumable-hash');\n\nconst defaultOptions = {\n  bits: 8\n};\n\nclass Bucket {\n  constructor(options, parent, posAtParent) {\n    this._options = Object.assign({}, defaultOptions, options);\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n\n    if (!this._options.hashFn) {\n      throw new Error('please define an options.hashFn');\n    } // make sure we only wrap options.hashFn once in the whole tree\n\n\n    if (!this._options.hash) {\n      this._options.hash = wrapHash(this._options.hashFn);\n    }\n\n    this._children = new SparseArray();\n  }\n\n  static isBucket(o) {\n    return o instanceof Bucket;\n  }\n\n  async put(key, value) {\n    const place = await this._findNewBucketAndPos(key);\n    await place.bucket._putAt(place, key, value);\n  }\n\n  async get(key) {\n    const child = await this._findChild(key);\n\n    if (child) {\n      return child.value;\n    }\n  }\n\n  async del(key) {\n    const place = await this._findPlace(key);\n\n    const child = place.bucket._at(place.pos);\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos);\n    }\n  }\n\n  leafCount() {\n    return this._children.compactArray().reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount();\n      }\n\n      return acc + 1;\n    }, 0);\n  }\n\n  childrenCount() {\n    return this._children.length;\n  }\n\n  onlyChild() {\n    return this._children.get(0);\n  }\n\n  *eachLeafSeries() {\n    const children = this._children.compactArray();\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        for (const c2 of child.eachLeafSeries()) {\n          yield c2;\n        }\n      } else {\n        yield child;\n      }\n    }\n  }\n\n  serialize(map, reduce) {\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce));\n        } else {\n          acc.push(map(child, index));\n        }\n      }\n\n      return acc;\n    }, []));\n  }\n\n  async asyncTransform(asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce);\n  }\n\n  toJSON() {\n    return this.serialize(mapNode, reduceNodes);\n  }\n\n  prettyPrint() {\n    return JSON.stringify(this.toJSON(), null, '  ');\n  }\n\n  tableSize() {\n    return Math.pow(2, this._options.bits);\n  }\n\n  async _findChild(key) {\n    const result = await this._findPlace(key);\n\n    const child = result.bucket._at(result.pos);\n\n    if (child && child.key === key) {\n      return child;\n    }\n  }\n\n  async _findPlace(key) {\n    const hashValue = this._options.hash(key);\n\n    const index = await hashValue.take(this._options.bits);\n\n    const child = this._children.get(index);\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue);\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue\n    };\n  }\n\n  async _findNewBucketAndPos(key) {\n    const place = await this._findPlace(key);\n\n    const child = place.bucket._at(place.pos);\n\n    if (child && child.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos);\n\n      place.bucket._putObjectAt(place.pos, bucket); // put the previous value\n\n\n      const newPlace = await bucket._findPlace(child.hash);\n\n      newPlace.bucket._putAt(newPlace, child.key, child.value);\n\n      return bucket._findNewBucketAndPos(place.hash);\n    } // no conflict, we found the place\n\n\n    return place;\n  }\n\n  _putAt(place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    });\n  }\n\n  _putObjectAt(pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++;\n    }\n\n    this._children.set(pos, object);\n  }\n\n  _delAt(pos) {\n    if (this._children.get(pos)) {\n      this._popCount--;\n    }\n\n    this._children.unset(pos);\n\n    this._level();\n  }\n\n  _level() {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists);\n\n        if (!(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash;\n          hash.untake(this._options.bits);\n          const place = {\n            pos: this._posAtParent,\n            hash: hash\n          };\n\n          this._parent._putAt(place, onlyChild.key, onlyChild.value);\n        }\n      } else {\n        this._parent._delAt(this._posAtParent);\n      }\n    }\n  }\n\n  _at(index) {\n    return this._children.get(index);\n  }\n\n}\n\nfunction exists(o) {\n  return Boolean(o);\n}\n\nfunction mapNode(node, index) {\n  return node.key;\n}\n\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n\nasync function asyncTransformBucket(bucket, asyncMap, asyncReduce) {\n  const output = [];\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce);\n    } else {\n      const mappedChildren = await asyncMap(child);\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      });\n    }\n\n    return asyncReduce(output);\n  }\n}\n\nmodule.exports = Bucket;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/hamt-sharding/src/bucket.js"],"names":["SparseArray","require","wrapHash","defaultOptions","bits","Bucket","constructor","options","parent","posAtParent","_options","Object","assign","_popCount","_parent","_posAtParent","hashFn","Error","hash","_children","isBucket","o","put","key","value","place","_findNewBucketAndPos","bucket","_putAt","get","child","_findChild","del","_findPlace","_at","pos","_delAt","leafCount","compactArray","reduce","acc","childrenCount","length","onlyChild","eachLeafSeries","children","c2","serialize","map","index","push","asyncTransform","asyncMap","asyncReduce","asyncTransformBucket","toJSON","mapNode","reduceNodes","prettyPrint","JSON","stringify","tableSize","Math","pow","result","hashValue","take","_putObjectAt","newPlace","object","set","unset","_level","find","exists","untake","Boolean","node","nodes","output","mappedChildren","bitField","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst SparseArray = require('sparse-array')\nconst wrapHash = require('./consumable-hash')\n\nconst defaultOptions = {\n  bits: 8\n}\n\nclass Bucket {\n  constructor (options, parent, posAtParent) {\n    this._options = Object.assign({}, defaultOptions, options)\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n\n    if (!this._options.hashFn) {\n      throw new Error('please define an options.hashFn')\n    }\n\n    // make sure we only wrap options.hashFn once in the whole tree\n    if (!this._options.hash) {\n      this._options.hash = wrapHash(this._options.hashFn)\n    }\n    this._children = new SparseArray()\n  }\n\n  static isBucket (o) {\n    return o instanceof Bucket\n  }\n\n  async put (key, value) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  async get (key) {\n    const child = await this._findChild(key)\n\n    if (child) {\n      return child.value\n    }\n  }\n\n  async del (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  leafCount () {\n    return this._children.compactArray().reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  * eachLeafSeries () {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        for (const c2 of child.eachLeafSeries()) {\n          yield c2\n        }\n      } else {\n        yield child\n      }\n    }\n  }\n\n  serialize (map, reduce) {\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, []))\n  }\n\n  async asyncTransform (asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  async _findChild (key) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child && child.key === key) {\n      return child\n    }\n  }\n\n  async _findPlace (key) {\n    const hashValue = this._options.hash(key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue\n    }\n  }\n\n  async _findNewBucketAndPos (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key !== key) {\n      // conflict\n\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(child.hash)\n      newPlace.bucket._putAt(newPlace, child.key, child.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  _putAt (place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  _putObjectAt (pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  _delAt (pos) {\n    if (this._children.get(pos)) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if (!(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  _at (index) {\n    return this._children.get(index)\n  }\n}\n\nfunction exists (o) {\n  return Boolean(o)\n}\n\nfunction mapNode (node, index) {\n  return node.key\n}\n\nfunction reduceNodes (nodes) {\n  return nodes\n}\n\nasync function asyncTransformBucket (bucket, asyncMap, asyncReduce) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n\n    return asyncReduce(output)\n  }\n}\n\nmodule.exports = Bucket\n"]},"metadata":{},"sourceType":"script"}