{"ast":null,"code":"\"use strict\";\n/**\n * Generate a character map.\n * @param {string} alphabet e.g. \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n * @param {object} mappings map overrides from key to value\n * @method\n */\n\nvar charmap = function (alphabet, mappings) {\n  mappings || (mappings = {});\n  alphabet.split(\"\").forEach(function (c, i) {\n    if (!(c in mappings)) mappings[c] = i;\n  });\n  return mappings;\n};\n/**\n * The RFC 4648 base 32 alphabet and character map.\n * @see {@link https://tools.ietf.org/html/rfc4648}\n */\n\n\nvar rfc4648 = {\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  charmap: {\n    0: 14,\n    1: 8\n  }\n};\nrfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);\n/**\n * The Crockford base 32 alphabet and character map.\n * @see {@link http://www.crockford.com/wrmg/base32.html}\n */\n\nvar crockford = {\n  alphabet: \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\",\n  charmap: {\n    O: 0,\n    I: 1,\n    L: 1\n  }\n};\ncrockford.charmap = charmap(crockford.alphabet, crockford.charmap);\n/**\n * base32hex\n * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}\n */\n\nvar base32hex = {\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  charmap: {}\n};\nbase32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);\n/**\n * Create a new `Decoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [charmap] Override the character map used in decoding.\n * @constructor\n */\n\nfunction Decoder(options) {\n  this.buf = [];\n  this.shift = 8;\n  this.carry = 0;\n\n  if (options) {\n    switch (options.type) {\n      case \"rfc4648\":\n        this.charmap = exports.rfc4648.charmap;\n        break;\n\n      case \"crockford\":\n        this.charmap = exports.crockford.charmap;\n        break;\n\n      case \"base32hex\":\n        this.charmap = exports.base32hex.charmap;\n        break;\n\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.charmap) this.charmap = options.charmap;\n  }\n}\n/**\n * The default character map coresponds to RFC4648.\n */\n\n\nDecoder.prototype.charmap = rfc4648.charmap;\n/**\n * Decode a string, continuing from the previous state.\n *\n * @param {string} str\n * @return {Decoder} this\n */\n\nDecoder.prototype.write = function (str) {\n  var charmap = this.charmap;\n  var buf = this.buf;\n  var shift = this.shift;\n  var carry = this.carry; // decode string\n\n  str.toUpperCase().split(\"\").forEach(function (char) {\n    // ignore padding\n    if (char == \"=\") return; // lookup symbol\n\n    var symbol = charmap[char] & 0xff; // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    shift -= 5;\n\n    if (shift > 0) {\n      carry |= symbol << shift;\n    } else if (shift < 0) {\n      buf.push(carry | symbol >> -shift);\n      shift += 8;\n      carry = symbol << shift & 0xff;\n    } else {\n      buf.push(carry | symbol);\n      shift = 8;\n      carry = 0;\n    }\n  }); // save state\n\n  this.shift = shift;\n  this.carry = carry; // for chaining\n\n  return this;\n};\n/**\n * Finish decoding.\n *\n * @param {string} [str] The final string to decode.\n * @return {Array} Decoded byte array.\n */\n\n\nDecoder.prototype.finalize = function (str) {\n  if (str) {\n    this.write(str);\n  }\n\n  if (this.shift !== 8 && this.carry !== 0) {\n    this.buf.push(this.carry);\n    this.shift = 8;\n    this.carry = 0;\n  }\n\n  return this.buf;\n};\n/**\n * Create a new `Encoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [alphabet] Override the alphabet used in encoding.\n * @constructor\n */\n\n\nfunction Encoder(options) {\n  this.buf = \"\";\n  this.shift = 3;\n  this.carry = 0;\n\n  if (options) {\n    switch (options.type) {\n      case \"rfc4648\":\n        this.alphabet = exports.rfc4648.alphabet;\n        break;\n\n      case \"crockford\":\n        this.alphabet = exports.crockford.alphabet;\n        break;\n\n      case \"base32hex\":\n        this.alphabet = exports.base32hex.alphabet;\n        break;\n\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.alphabet) this.alphabet = options.alphabet;else if (options.lc) this.alphabet = this.alphabet.toLowerCase();\n  }\n}\n/**\n * The default alphabet coresponds to RFC4648.\n */\n\n\nEncoder.prototype.alphabet = rfc4648.alphabet;\n/**\n * Encode a byte array, continuing from the previous state.\n *\n * @param {byte[]} buf The byte array to encode.\n * @return {Encoder} this\n */\n\nEncoder.prototype.write = function (buf) {\n  var shift = this.shift;\n  var carry = this.carry;\n  var symbol;\n  var byte;\n  var i; // encode each byte in buf\n\n  for (i = 0; i < buf.length; i++) {\n    byte = buf[i]; // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    symbol = carry | byte >> shift;\n    this.buf += this.alphabet[symbol & 0x1f];\n\n    if (shift > 5) {\n      shift -= 5;\n      symbol = byte >> shift;\n      this.buf += this.alphabet[symbol & 0x1f];\n    }\n\n    shift = 5 - shift;\n    carry = byte << shift;\n    shift = 8 - shift;\n  } // save state\n\n\n  this.shift = shift;\n  this.carry = carry; // for chaining\n\n  return this;\n};\n/**\n * Finish encoding.\n *\n * @param {byte[]} [buf] The final byte array to encode.\n * @return {string} The encoded byte array.\n */\n\n\nEncoder.prototype.finalize = function (buf) {\n  if (buf) {\n    this.write(buf);\n  }\n\n  if (this.shift !== 3) {\n    this.buf += this.alphabet[this.carry & 0x1f];\n    this.shift = 3;\n    this.carry = 0;\n  }\n\n  return this.buf;\n};\n/**\n * Convenience encoder.\n *\n * @param {byte[]} buf The byte array to encode.\n * @param {object} [options] Options to pass to the encoder.\n * @return {string} The encoded string.\n */\n\n\nexports.encode = function (buf, options) {\n  return new Encoder(options).finalize(buf);\n};\n/**\n * Convenience decoder.\n *\n * @param {string} str The string to decode.\n * @param {object} [options] Options to pass to the decoder.\n * @return {byte[]} The decoded byte array.\n */\n\n\nexports.decode = function (str, options) {\n  return new Decoder(options).finalize(str);\n}; // Exports.\n\n\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.charmap = charmap;\nexports.crockford = crockford;\nexports.rfc4648 = rfc4648;\nexports.base32hex = base32hex;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/base32.js/base32.js"],"names":["charmap","alphabet","mappings","split","forEach","c","i","rfc4648","crockford","O","I","L","base32hex","Decoder","options","buf","shift","carry","type","exports","Error","prototype","write","str","toUpperCase","char","symbol","push","finalize","Encoder","lc","toLowerCase","byte","length","encode","decode"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * Generate a character map.\n * @param {string} alphabet e.g. \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n * @param {object} mappings map overrides from key to value\n * @method\n */\n\nvar charmap = function (alphabet, mappings) {\n  mappings || (mappings = {});\n  alphabet.split(\"\").forEach(function (c, i) {\n    if (!(c in mappings)) mappings[c] = i;\n  });\n  return mappings;\n}\n\n/**\n * The RFC 4648 base 32 alphabet and character map.\n * @see {@link https://tools.ietf.org/html/rfc4648}\n */\n\nvar rfc4648 = {\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  charmap: {\n    0: 14,\n    1: 8\n  }\n};\n\nrfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);\n\n/**\n * The Crockford base 32 alphabet and character map.\n * @see {@link http://www.crockford.com/wrmg/base32.html}\n */\n\nvar crockford = {\n  alphabet: \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\",\n  charmap: {\n    O: 0,\n    I: 1,\n    L: 1\n  }\n};\n\ncrockford.charmap = charmap(crockford.alphabet, crockford.charmap);\n\n/**\n * base32hex\n * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}\n */\n\nvar base32hex = {\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  charmap: {}\n};\n\nbase32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);\n\n/**\n * Create a new `Decoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [charmap] Override the character map used in decoding.\n * @constructor\n */\n\nfunction Decoder (options) {\n  this.buf = [];\n  this.shift = 8;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.charmap = exports.rfc4648.charmap;\n        break;\n      case \"crockford\":\n        this.charmap = exports.crockford.charmap;\n        break;\n      case \"base32hex\":\n        this.charmap = exports.base32hex.charmap;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.charmap) this.charmap = options.charmap;\n  }\n}\n\n/**\n * The default character map coresponds to RFC4648.\n */\n\nDecoder.prototype.charmap = rfc4648.charmap;\n\n/**\n * Decode a string, continuing from the previous state.\n *\n * @param {string} str\n * @return {Decoder} this\n */\n\nDecoder.prototype.write = function (str) {\n  var charmap = this.charmap;\n  var buf = this.buf;\n  var shift = this.shift;\n  var carry = this.carry;\n\n  // decode string\n  str.toUpperCase().split(\"\").forEach(function (char) {\n\n    // ignore padding\n    if (char == \"=\") return;\n\n    // lookup symbol\n    var symbol = charmap[char] & 0xff;\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    shift -= 5;\n    if (shift > 0) {\n      carry |= symbol << shift;\n    } else if (shift < 0) {\n      buf.push(carry | (symbol >> -shift));\n      shift += 8;\n      carry = (symbol << shift) & 0xff;\n    } else {\n      buf.push(carry | symbol);\n      shift = 8;\n      carry = 0;\n    }\n  });\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish decoding.\n *\n * @param {string} [str] The final string to decode.\n * @return {Array} Decoded byte array.\n */\n\nDecoder.prototype.finalize = function (str) {\n  if (str) {\n    this.write(str);\n  }\n  if (this.shift !== 8 && this.carry !== 0) {\n    this.buf.push(this.carry);\n    this.shift = 8;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Create a new `Encoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [alphabet] Override the alphabet used in encoding.\n * @constructor\n */\n\nfunction Encoder (options) {\n  this.buf = \"\";\n  this.shift = 3;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.alphabet = exports.rfc4648.alphabet;\n        break;\n      case \"crockford\":\n        this.alphabet = exports.crockford.alphabet;\n        break;\n      case \"base32hex\":\n        this.alphabet = exports.base32hex.alphabet;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.alphabet) this.alphabet = options.alphabet;\n    else if (options.lc) this.alphabet = this.alphabet.toLowerCase();\n  }\n}\n\n/**\n * The default alphabet coresponds to RFC4648.\n */\n\nEncoder.prototype.alphabet = rfc4648.alphabet;\n\n/**\n * Encode a byte array, continuing from the previous state.\n *\n * @param {byte[]} buf The byte array to encode.\n * @return {Encoder} this\n */\n\nEncoder.prototype.write = function (buf) {\n  var shift = this.shift;\n  var carry = this.carry;\n  var symbol;\n  var byte;\n  var i;\n\n  // encode each byte in buf\n  for (i = 0; i < buf.length; i++) {\n    byte = buf[i];\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    symbol = carry | (byte >> shift);\n    this.buf += this.alphabet[symbol & 0x1f];\n\n    if (shift > 5) {\n      shift -= 5;\n      symbol = byte >> shift;\n      this.buf += this.alphabet[symbol & 0x1f];\n    }\n\n    shift = 5 - shift;\n    carry = byte << shift;\n    shift = 8 - shift;\n  }\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish encoding.\n *\n * @param {byte[]} [buf] The final byte array to encode.\n * @return {string} The encoded byte array.\n */\n\nEncoder.prototype.finalize = function (buf) {\n  if (buf) {\n    this.write(buf);\n  }\n  if (this.shift !== 3) {\n    this.buf += this.alphabet[this.carry & 0x1f];\n    this.shift = 3;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Convenience encoder.\n *\n * @param {byte[]} buf The byte array to encode.\n * @param {object} [options] Options to pass to the encoder.\n * @return {string} The encoded string.\n */\n\nexports.encode = function (buf, options) {\n  return new Encoder(options).finalize(buf);\n};\n\n/**\n * Convenience decoder.\n *\n * @param {string} str The string to decode.\n * @param {object} [options] Options to pass to the decoder.\n * @return {byte[]} The decoded byte array.\n */\n\nexports.decode = function (str, options) {\n  return new Decoder(options).finalize(str);\n};\n\n// Exports.\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.charmap = charmap;\nexports.crockford = crockford;\nexports.rfc4648 = rfc4648;\nexports.base32hex = base32hex;\n"]},"metadata":{},"sourceType":"script"}