{"ast":null,"code":"'use strict';\n\nconst AggregateError = require('aggregate-error');\n\nmodule.exports = async (iterable, mapper, {\n  concurrency = Infinity,\n  stopOnError = true\n} = {}) => {\n  return new Promise((resolve, reject) => {\n    if (typeof mapper !== 'function') {\n      throw new TypeError('Mapper function is required');\n    }\n\n    if (!(typeof concurrency === 'number' && concurrency >= 1)) {\n      throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${concurrency}\\` (${typeof concurrency})`);\n    }\n\n    const ret = [];\n    const errors = [];\n    const iterator = iterable[Symbol.iterator]();\n    let isRejected = false;\n    let isIterableDone = false;\n    let resolvingCount = 0;\n    let currentIndex = 0;\n\n    const next = () => {\n      if (isRejected) {\n        return;\n      }\n\n      const nextItem = iterator.next();\n      const i = currentIndex;\n      currentIndex++;\n\n      if (nextItem.done) {\n        isIterableDone = true;\n\n        if (resolvingCount === 0) {\n          if (!stopOnError && errors.length !== 0) {\n            reject(new AggregateError(errors));\n          } else {\n            resolve(ret);\n          }\n        }\n\n        return;\n      }\n\n      resolvingCount++;\n\n      (async () => {\n        try {\n          const element = await nextItem.value;\n          ret[i] = await mapper(element, i);\n          resolvingCount--;\n          next();\n        } catch (error) {\n          if (stopOnError) {\n            isRejected = true;\n            reject(error);\n          } else {\n            errors.push(error);\n            resolvingCount--;\n            next();\n          }\n        }\n      })();\n    };\n\n    for (let i = 0; i < concurrency; i++) {\n      next();\n\n      if (isIterableDone) {\n        break;\n      }\n    }\n  });\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/orbit-db-store/node_modules/p-map/index.js"],"names":["AggregateError","require","module","exports","iterable","mapper","concurrency","Infinity","stopOnError","Promise","resolve","reject","TypeError","ret","errors","iterator","Symbol","isRejected","isIterableDone","resolvingCount","currentIndex","next","nextItem","i","done","length","element","value","error","push"],"mappings":"AAAA;;AACA,MAAMA,cAAc,GAAGC,OAAO,CAAC,iBAAD,CAA9B;;AAEAC,MAAM,CAACC,OAAP,GAAiB,OAChBC,QADgB,EAEhBC,MAFgB,EAGhB;AACCC,EAAAA,WAAW,GAAGC,QADf;AAECC,EAAAA,WAAW,GAAG;AAFf,IAGI,EANY,KAOZ;AACJ,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvC,QAAI,OAAON,MAAP,KAAkB,UAAtB,EAAkC;AACjC,YAAM,IAAIO,SAAJ,CAAc,6BAAd,CAAN;AACA;;AAED,QAAI,EAAE,OAAON,WAAP,KAAuB,QAAvB,IAAmCA,WAAW,IAAI,CAApD,CAAJ,EAA4D;AAC3D,YAAM,IAAIM,SAAJ,CAAe,gEAA+DN,WAAY,OAAM,OAAOA,WAAY,GAAnH,CAAN;AACA;;AAED,UAAMO,GAAG,GAAG,EAAZ;AACA,UAAMC,MAAM,GAAG,EAAf;AACA,UAAMC,QAAQ,GAAGX,QAAQ,CAACY,MAAM,CAACD,QAAR,CAAR,EAAjB;AACA,QAAIE,UAAU,GAAG,KAAjB;AACA,QAAIC,cAAc,GAAG,KAArB;AACA,QAAIC,cAAc,GAAG,CAArB;AACA,QAAIC,YAAY,GAAG,CAAnB;;AAEA,UAAMC,IAAI,GAAG,MAAM;AAClB,UAAIJ,UAAJ,EAAgB;AACf;AACA;;AAED,YAAMK,QAAQ,GAAGP,QAAQ,CAACM,IAAT,EAAjB;AACA,YAAME,CAAC,GAAGH,YAAV;AACAA,MAAAA,YAAY;;AAEZ,UAAIE,QAAQ,CAACE,IAAb,EAAmB;AAClBN,QAAAA,cAAc,GAAG,IAAjB;;AAEA,YAAIC,cAAc,KAAK,CAAvB,EAA0B;AACzB,cAAI,CAACX,WAAD,IAAgBM,MAAM,CAACW,MAAP,KAAkB,CAAtC,EAAyC;AACxCd,YAAAA,MAAM,CAAC,IAAIX,cAAJ,CAAmBc,MAAnB,CAAD,CAAN;AACA,WAFD,MAEO;AACNJ,YAAAA,OAAO,CAACG,GAAD,CAAP;AACA;AACD;;AAED;AACA;;AAEDM,MAAAA,cAAc;;AAEd,OAAC,YAAY;AACZ,YAAI;AACH,gBAAMO,OAAO,GAAG,MAAMJ,QAAQ,CAACK,KAA/B;AACAd,UAAAA,GAAG,CAACU,CAAD,CAAH,GAAS,MAAMlB,MAAM,CAACqB,OAAD,EAAUH,CAAV,CAArB;AACAJ,UAAAA,cAAc;AACdE,UAAAA,IAAI;AACJ,SALD,CAKE,OAAOO,KAAP,EAAc;AACf,cAAIpB,WAAJ,EAAiB;AAChBS,YAAAA,UAAU,GAAG,IAAb;AACAN,YAAAA,MAAM,CAACiB,KAAD,CAAN;AACA,WAHD,MAGO;AACNd,YAAAA,MAAM,CAACe,IAAP,CAAYD,KAAZ;AACAT,YAAAA,cAAc;AACdE,YAAAA,IAAI;AACJ;AACD;AACD,OAhBD;AAiBA,KA1CD;;AA4CA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjB,WAApB,EAAiCiB,CAAC,EAAlC,EAAsC;AACrCF,MAAAA,IAAI;;AAEJ,UAAIH,cAAJ,EAAoB;AACnB;AACA;AACD;AACD,GApEM,CAAP;AAqEA,CA7ED","sourcesContent":["'use strict';\nconst AggregateError = require('aggregate-error');\n\nmodule.exports = async (\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Infinity,\n\t\tstopOnError = true\n\t} = {}\n) => {\n\treturn new Promise((resolve, reject) => {\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!(typeof concurrency === 'number' && concurrency >= 1)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst ret = [];\n\t\tconst errors = [];\n\t\tconst iterator = iterable[Symbol.iterator]();\n\t\tlet isRejected = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\n\t\tconst next = () => {\n\t\t\tif (isRejected) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = iterator.next();\n\t\t\tconst i = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0) {\n\t\t\t\t\tif (!stopOnError && errors.length !== 0) {\n\t\t\t\t\t\treject(new AggregateError(errors));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\t\t\t\t\tret[i] = await mapper(element, i);\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\tisRejected = true;\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\tfor (let i = 0; i < concurrency; i++) {\n\t\t\tnext();\n\n\t\t\tif (isIterableDone) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}