{"ast":null,"code":"/* global IDBKeyRange */\n'use strict';\n\nvar inherits = require('inherits');\n\nvar AbstractIterator = require('abstract-leveldown').AbstractIterator;\n\nvar ltgt = require('ltgt');\n\nvar mixedToBuffer = require('./util/mixed-to-buffer');\n\nvar setImmediate = require('./util/immediate');\n\nvar noop = function () {};\n\nmodule.exports = Iterator;\n\nfunction Iterator(db, location, options) {\n  AbstractIterator.call(this, db);\n  this._limit = options.limit;\n  this._count = 0;\n  this._callback = null;\n  this._cache = [];\n  this._completed = false;\n  this._aborted = false;\n  this._error = null;\n  this._transaction = null;\n  this._keyAsBuffer = options.keyAsBuffer;\n  this._valueAsBuffer = options.valueAsBuffer;\n\n  if (this._limit === 0) {\n    this._completed = true;\n    return;\n  }\n\n  try {\n    var keyRange = this.createKeyRange(options);\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just return 0 results.\n    this._completed = true;\n    return;\n  }\n\n  this.createIterator(location, keyRange, options.reverse);\n}\n\ninherits(Iterator, AbstractIterator);\n\nIterator.prototype.createKeyRange = function (options) {\n  var lower = ltgt.lowerBound(options);\n  var upper = ltgt.upperBound(options);\n  var lowerOpen = ltgt.lowerBoundExclusive(options);\n  var upperOpen = ltgt.upperBoundExclusive(options);\n\n  if (lower !== undefined && upper !== undefined) {\n    return IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen);\n  } else if (lower !== undefined) {\n    return IDBKeyRange.lowerBound(lower, lowerOpen);\n  } else if (upper !== undefined) {\n    return IDBKeyRange.upperBound(upper, upperOpen);\n  } else {\n    return null;\n  }\n};\n\nIterator.prototype.createIterator = function (location, keyRange, reverse) {\n  var self = this;\n  var transaction = this.db.db.transaction([location], 'readonly');\n  var store = transaction.objectStore(location);\n  var req = store.openCursor(keyRange, reverse ? 'prev' : 'next');\n\n  req.onsuccess = function (ev) {\n    var cursor = ev.target.result;\n    if (cursor) self.onItem(cursor);\n  };\n\n  this._transaction = transaction; // If an error occurs (on the request), the transaction will abort.\n\n  transaction.onabort = function () {\n    self.onAbort(self._transaction.error || new Error('aborted by user'));\n  };\n\n  transaction.oncomplete = function () {\n    self.onComplete();\n  };\n};\n\nIterator.prototype.onItem = function (cursor) {\n  this._cache.push(cursor.key, cursor.value);\n\n  if (this._limit <= 0 || ++this._count < this._limit) {\n    cursor['continue']();\n  }\n\n  this.maybeNext();\n};\n\nIterator.prototype.onAbort = function (err) {\n  this._aborted = true;\n  this._error = err;\n  this.maybeNext();\n};\n\nIterator.prototype.onComplete = function () {\n  this._completed = true;\n  this.maybeNext();\n};\n\nIterator.prototype.maybeNext = function () {\n  if (this._callback) {\n    this._next(this._callback);\n\n    this._callback = null;\n  }\n};\n\nIterator.prototype._next = function (callback) {\n  if (this._aborted) {\n    // The error should be picked up by either next() or end().\n    var err = this._error;\n    this._error = null;\n    setImmediate(function () {\n      callback(err);\n    });\n  } else if (this._cache.length > 0) {\n    var key = this._cache.shift();\n\n    var value = this._cache.shift();\n\n    if (this._keyAsBuffer) key = mixedToBuffer(key);\n    if (this._valueAsBuffer) value = mixedToBuffer(value);\n    setImmediate(function () {\n      callback(null, key, value);\n    });\n  } else if (this._completed) {\n    setImmediate(callback);\n  } else {\n    this._callback = callback;\n  }\n};\n\nIterator.prototype._end = function (callback) {\n  if (this._aborted || this._completed) {\n    var err = this._error;\n    setImmediate(function () {\n      callback(err);\n    });\n    return;\n  } // Don't advance the cursor anymore, and the transaction will complete\n  // on its own in the next tick. This approach is much cleaner than calling\n  // transaction.abort() with its unpredictable event order.\n\n\n  this.onItem = noop;\n  this.onAbort = callback;\n  this.onComplete = callback;\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/level-js/iterator.js"],"names":["inherits","require","AbstractIterator","ltgt","mixedToBuffer","setImmediate","noop","module","exports","Iterator","db","location","options","call","_limit","limit","_count","_callback","_cache","_completed","_aborted","_error","_transaction","_keyAsBuffer","keyAsBuffer","_valueAsBuffer","valueAsBuffer","keyRange","createKeyRange","e","createIterator","reverse","prototype","lower","lowerBound","upper","upperBound","lowerOpen","lowerBoundExclusive","upperOpen","upperBoundExclusive","undefined","IDBKeyRange","bound","self","transaction","store","objectStore","req","openCursor","onsuccess","ev","cursor","target","result","onItem","onabort","onAbort","error","Error","oncomplete","onComplete","push","key","value","maybeNext","err","_next","callback","length","shift","_end"],"mappings":"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","sourcesContent":["/* global IDBKeyRange */\n\n'use strict'\n\nvar inherits = require('inherits')\nvar AbstractIterator = require('abstract-leveldown').AbstractIterator\nvar ltgt = require('ltgt')\nvar mixedToBuffer = require('./util/mixed-to-buffer')\nvar setImmediate = require('./util/immediate')\nvar noop = function () {}\n\nmodule.exports = Iterator\n\nfunction Iterator (db, location, options) {\n  AbstractIterator.call(this, db)\n\n  this._limit = options.limit\n  this._count = 0\n  this._callback = null\n  this._cache = []\n  this._completed = false\n  this._aborted = false\n  this._error = null\n  this._transaction = null\n\n  this._keyAsBuffer = options.keyAsBuffer\n  this._valueAsBuffer = options.valueAsBuffer\n\n  if (this._limit === 0) {\n    this._completed = true\n    return\n  }\n\n  try {\n    var keyRange = this.createKeyRange(options)\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just return 0 results.\n    this._completed = true\n    return\n  }\n\n  this.createIterator(location, keyRange, options.reverse)\n}\n\ninherits(Iterator, AbstractIterator)\n\nIterator.prototype.createKeyRange = function (options) {\n  var lower = ltgt.lowerBound(options)\n  var upper = ltgt.upperBound(options)\n  var lowerOpen = ltgt.lowerBoundExclusive(options)\n  var upperOpen = ltgt.upperBoundExclusive(options)\n\n  if (lower !== undefined && upper !== undefined) {\n    return IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)\n  } else if (lower !== undefined) {\n    return IDBKeyRange.lowerBound(lower, lowerOpen)\n  } else if (upper !== undefined) {\n    return IDBKeyRange.upperBound(upper, upperOpen)\n  } else {\n    return null\n  }\n}\n\nIterator.prototype.createIterator = function (location, keyRange, reverse) {\n  var self = this\n  var transaction = this.db.db.transaction([location], 'readonly')\n  var store = transaction.objectStore(location)\n  var req = store.openCursor(keyRange, reverse ? 'prev' : 'next')\n\n  req.onsuccess = function (ev) {\n    var cursor = ev.target.result\n    if (cursor) self.onItem(cursor)\n  }\n\n  this._transaction = transaction\n\n  // If an error occurs (on the request), the transaction will abort.\n  transaction.onabort = function () {\n    self.onAbort(self._transaction.error || new Error('aborted by user'))\n  }\n\n  transaction.oncomplete = function () {\n    self.onComplete()\n  }\n}\n\nIterator.prototype.onItem = function (cursor) {\n  this._cache.push(cursor.key, cursor.value)\n\n  if (this._limit <= 0 || ++this._count < this._limit) {\n    cursor['continue']()\n  }\n\n  this.maybeNext()\n}\n\nIterator.prototype.onAbort = function (err) {\n  this._aborted = true\n  this._error = err\n  this.maybeNext()\n}\n\nIterator.prototype.onComplete = function () {\n  this._completed = true\n  this.maybeNext()\n}\n\nIterator.prototype.maybeNext = function () {\n  if (this._callback) {\n    this._next(this._callback)\n    this._callback = null\n  }\n}\n\nIterator.prototype._next = function (callback) {\n  if (this._aborted) {\n    // The error should be picked up by either next() or end().\n    var err = this._error\n    this._error = null\n\n    setImmediate(function () {\n      callback(err)\n    })\n  } else if (this._cache.length > 0) {\n    var key = this._cache.shift()\n    var value = this._cache.shift()\n\n    if (this._keyAsBuffer) key = mixedToBuffer(key)\n    if (this._valueAsBuffer) value = mixedToBuffer(value)\n\n    setImmediate(function () {\n      callback(null, key, value)\n    })\n  } else if (this._completed) {\n    setImmediate(callback)\n  } else {\n    this._callback = callback\n  }\n}\n\nIterator.prototype._end = function (callback) {\n  if (this._aborted || this._completed) {\n    var err = this._error\n\n    setImmediate(function () {\n      callback(err)\n    })\n\n    return\n  }\n\n  // Don't advance the cursor anymore, and the transaction will complete\n  // on its own in the next tick. This approach is much cleaner than calling\n  // transaction.abort() with its unpredictable event order.\n  this.onItem = noop\n  this.onAbort = callback\n  this.onComplete = callback\n}\n"]},"metadata":{},"sourceType":"script"}