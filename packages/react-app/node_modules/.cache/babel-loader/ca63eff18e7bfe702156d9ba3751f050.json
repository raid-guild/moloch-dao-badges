{"ast":null,"code":"'use strict';\n\nconst fs = typeof window === 'object' || typeof self === 'object' ? null : eval('require(\"fs\")'); // eslint-disable-line\n\nconst level = require('level');\n\nconst crypto = require('libp2p-crypto');\n\nconst secp256k1 = require('secp256k1');\n\nconst LRU = require('lru');\n\nconst Buffer = require('safe-buffer/').Buffer;\n\nconst {\n  verifier\n} = require('./verifiers');\n\nfunction createStore(path = './keystore') {\n  if (fs && fs.mkdirSync) {\n    fs.mkdirSync(path, {\n      recursive: true\n    });\n  }\n\n  return level(path);\n}\n\nconst verifiedCache = new LRU(1000);\n\nclass Keystore {\n  constructor(input = {}) {\n    if (typeof input === 'string') {\n      this._store = createStore(input);\n    } else if (typeof input.open === 'function') {\n      this._store = input;\n    } else if (typeof input.store === 'string') {\n      this._store = createStore(input.store);\n    } else {\n      this._store = input.store || createStore();\n    }\n\n    this._cache = input.cache || new LRU(100);\n  }\n\n  async open() {\n    if (this._store) {\n      await this._store.open();\n      return Promise.resolve();\n    }\n\n    return Promise.reject(new Error('Keystore: No store found to open'));\n  }\n\n  async close() {\n    if (!this._store) return;\n    await this._store.close();\n  }\n\n  async hasKey(id) {\n    if (!id) {\n      throw new Error('id needed to check a key');\n    }\n\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null);\n    }\n\n    let hasKey = false;\n\n    try {\n      let storedKey = this._cache.get(id) || (await this._store.get(id));\n      hasKey = storedKey !== undefined && storedKey !== null;\n    } catch (e) {\n      // Catches 'Error: ENOENT: no such file or directory, open <path>'\n      console.error('Error: ENOENT: no such file or directory');\n    }\n\n    return hasKey;\n  }\n\n  async createKey(id) {\n    if (!id) {\n      throw new Error('id needed to create a key');\n    }\n\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null);\n    }\n\n    const genKeyPair = () => new Promise((resolve, reject) => {\n      crypto.keys.generateKeyPair('secp256k1', 256, (err, key) => {\n        if (!err) {\n          resolve(key);\n        }\n\n        reject(err);\n      });\n    });\n\n    const keys = await genKeyPair();\n    const decompressedKey = secp256k1.publicKeyConvert(keys.public.marshal(), false);\n    const key = {\n      publicKey: decompressedKey.toString('hex'),\n      privateKey: keys.marshal().toString('hex')\n    };\n\n    try {\n      await this._store.put(id, JSON.stringify(key));\n    } catch (e) {\n      console.log(e);\n    }\n\n    this._cache.set(id, key);\n\n    return keys;\n  }\n\n  async getKey(id) {\n    if (!id) {\n      throw new Error('id needed to get a key');\n    }\n\n    if (!this._store) {\n      await this.open();\n    }\n\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null);\n    }\n\n    const cachedKey = this._cache.get(id);\n\n    let storedKey;\n\n    try {\n      storedKey = cachedKey || (await this._store.get(id));\n    } catch (e) {// ignore ENOENT error\n    }\n\n    if (!storedKey) {\n      return;\n    }\n\n    const deserializedKey = cachedKey || JSON.parse(storedKey);\n\n    if (!deserializedKey) {\n      return;\n    }\n\n    if (!cachedKey) {\n      this._cache.set(id, deserializedKey);\n    }\n\n    const genPrivKey = pk => new Promise((resolve, reject) => {\n      crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(pk, (err, key) => {\n        if (!err) {\n          resolve(key);\n        }\n\n        reject(err);\n      });\n    });\n\n    return genPrivKey(Buffer.from(deserializedKey.privateKey, 'hex'));\n  }\n\n  async sign(key, data) {\n    if (!key) {\n      throw new Error('No signing key given');\n    }\n\n    if (!data) {\n      throw new Error('Given input data was undefined');\n    }\n\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data);\n    }\n\n    return new Promise((resolve, reject) => {\n      key.sign(data, (err, signature) => {\n        if (!err) {\n          resolve(signature.toString('hex'));\n        }\n\n        reject(err);\n      });\n    });\n  }\n\n  getPublic(keys, options = {}) {\n    const formats = ['hex', 'buffer'];\n    const decompress = typeof options.decompress === 'undefined' ? true : options.decompress;\n    const format = options.format || 'hex';\n\n    if (formats.indexOf(format) === -1) {\n      throw new Error('Supported formats are `hex` and `buffer`');\n    }\n\n    let pubKey = keys.public.marshal();\n\n    if (decompress) {\n      pubKey = secp256k1.publicKeyConvert(pubKey, false);\n    }\n\n    return format === 'buffer' ? pubKey : pubKey.toString('hex');\n  }\n\n  async verify(signature, publicKey, data, v = 'v1') {\n    return Keystore.verify(signature, publicKey, data, v);\n  }\n\n  static async verify(signature, publicKey, data, v = 'v1') {\n    const cached = verifiedCache.get(signature);\n    let res = false;\n\n    if (!cached) {\n      const verified = await verifier(v).verify(signature, publicKey, data);\n      res = verified;\n\n      if (verified) {\n        verifiedCache.set(signature, {\n          publicKey,\n          data\n        });\n      }\n    } else {\n      const compare = (cached, data, v) => {\n        let match;\n\n        if (v === 'v0') {\n          match = Buffer.compare(Buffer.alloc(30, cached), Buffer.alloc(30, data)) === 0;\n        } else {\n          match = Buffer.isBuffer(data) ? Buffer.compare(cached, data) === 0 : cached === data;\n        }\n\n        return match;\n      };\n\n      res = cached.publicKey === publicKey && compare(cached.data, data, v);\n    }\n\n    return res;\n  }\n\n}\n\nmodule.exports = Keystore;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/orbit-db-keystore/src/keystore.js"],"names":["fs","window","self","eval","level","require","crypto","secp256k1","LRU","Buffer","verifier","createStore","path","mkdirSync","recursive","verifiedCache","Keystore","constructor","input","_store","open","store","_cache","cache","Promise","resolve","reject","Error","close","hasKey","id","status","storedKey","get","undefined","e","console","error","createKey","genKeyPair","keys","generateKeyPair","err","key","decompressedKey","publicKeyConvert","public","marshal","publicKey","toString","privateKey","put","JSON","stringify","log","set","getKey","cachedKey","deserializedKey","parse","genPrivKey","pk","supportedKeys","unmarshalSecp256k1PrivateKey","from","sign","data","isBuffer","signature","getPublic","options","formats","decompress","format","indexOf","pubKey","verify","v","cached","res","verified","compare","match","alloc","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = (typeof window === 'object' || typeof self === 'object') ? null : eval('require(\"fs\")') // eslint-disable-line\nconst level = require('level')\nconst crypto = require('libp2p-crypto')\nconst secp256k1 = require('secp256k1')\nconst LRU = require('lru')\nconst Buffer = require('safe-buffer/').Buffer\nconst { verifier } = require('./verifiers')\n\nfunction createStore (path = './keystore') {\n  if (fs && fs.mkdirSync) {\n    fs.mkdirSync(path, { recursive: true })\n  }\n  return level(path)\n}\nconst verifiedCache = new LRU(1000)\n\nclass Keystore {\n  constructor (input = {}) {\n    if (typeof input === 'string') {\n      this._store = createStore(input)\n    } else if (typeof input.open === 'function') {\n      this._store = input\n    } else if (typeof input.store === 'string') {\n      this._store = createStore(input.store)\n    } else {\n      this._store = input.store || createStore()\n    }\n    this._cache = input.cache || new LRU(100)\n  }\n\n  async open () {\n    if (this._store) {\n      await this._store.open()\n      return Promise.resolve()\n    }\n    return Promise.reject(new Error('Keystore: No store found to open'))\n  }\n\n  async close () {\n    if (!this._store) return\n    await this._store.close()\n  }\n\n  async hasKey (id) {\n    if (!id) {\n      throw new Error('id needed to check a key')\n    }\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null)\n    }\n\n    let hasKey = false\n    try {\n      let storedKey = this._cache.get(id) || await this._store.get(id)\n      hasKey = storedKey !== undefined && storedKey !== null\n    } catch (e) {\n      // Catches 'Error: ENOENT: no such file or directory, open <path>'\n      console.error('Error: ENOENT: no such file or directory')\n    }\n\n    return hasKey\n  }\n\n  async createKey (id) {\n    if (!id) {\n      throw new Error('id needed to create a key')\n    }\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null)\n    }\n\n    const genKeyPair = () => new Promise((resolve, reject) => {\n      crypto.keys.generateKeyPair('secp256k1', 256, (err, key) => {\n        if (!err) {\n          resolve(key)\n        }\n        reject(err)\n      })\n    })\n\n    const keys = await genKeyPair()\n    const decompressedKey = secp256k1.publicKeyConvert(keys.public.marshal(), false)\n    const key = {\n      publicKey: decompressedKey.toString('hex'),\n      privateKey: keys.marshal().toString('hex')\n    }\n\n    try {\n      await this._store.put(id, JSON.stringify(key))\n    } catch (e) {\n      console.log(e)\n    }\n    this._cache.set(id, key)\n\n    return keys\n  }\n\n  async getKey (id) {\n    if (!id) {\n      throw new Error('id needed to get a key')\n    }\n    if (!this._store) {\n      await this.open()\n    }\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null)\n    }\n\n    const cachedKey = this._cache.get(id)\n    let storedKey\n    try {\n      storedKey = cachedKey || await this._store.get(id)\n    } catch (e) {\n      // ignore ENOENT error\n    }\n\n    if (!storedKey) {\n      return\n    }\n\n    const deserializedKey = cachedKey || JSON.parse(storedKey)\n    if (!deserializedKey) {\n      return\n    }\n\n    if (!cachedKey) {\n      this._cache.set(id, deserializedKey)\n    }\n\n    const genPrivKey = (pk) => new Promise((resolve, reject) => {\n      crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(pk, (err, key) => {\n        if (!err) {\n          resolve(key)\n        }\n        reject(err)\n      })\n    })\n\n    return genPrivKey(Buffer.from(deserializedKey.privateKey, 'hex'))\n  }\n\n  async sign (key, data) {\n    if (!key) {\n      throw new Error('No signing key given')\n    }\n\n    if (!data) {\n      throw new Error('Given input data was undefined')\n    }\n\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data)\n    }\n\n    return new Promise((resolve, reject) => {\n      key.sign(data, (err, signature) => {\n        if (!err) {\n          resolve(signature.toString('hex'))\n        }\n        reject(err)\n      })\n    })\n  }\n\n  getPublic (keys, options = {}) {\n    const formats = ['hex', 'buffer']\n    const decompress = typeof options.decompress === 'undefined' ? true : options.decompress\n    const format = options.format || 'hex'\n    if (formats.indexOf(format) === -1) {\n      throw new Error('Supported formats are `hex` and `buffer`')\n    }\n    let pubKey = keys.public.marshal()\n    if (decompress) {\n      pubKey = secp256k1.publicKeyConvert(pubKey, false)\n    }\n    return format === 'buffer' ? pubKey : pubKey.toString('hex')\n  }\n\n  async verify (signature, publicKey, data, v = 'v1') {\n    return Keystore.verify(signature, publicKey, data, v)\n  }\n\n  static async verify (signature, publicKey, data, v = 'v1') {\n    const cached = verifiedCache.get(signature)\n    let res = false\n    if (!cached) {\n      const verified = await verifier(v).verify(signature, publicKey, data)\n      res = verified\n      if (verified) {\n        verifiedCache.set(signature, { publicKey, data })\n      }\n    } else {\n      const compare = (cached, data, v) => {\n        let match\n        if (v === 'v0') {\n          match = Buffer.compare(Buffer.alloc(30, cached), Buffer.alloc(30, data)) === 0\n        } else {\n          match = Buffer.isBuffer(data) ? Buffer.compare(cached, data) === 0 : cached === data\n        }\n        return match\n      }\n      res = cached.publicKey === publicKey && compare(cached.data, data, v)\n    }\n    return res\n  }\n}\n\nmodule.exports = Keystore\n"]},"metadata":{},"sourceType":"script"}