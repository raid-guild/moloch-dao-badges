{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst extractDataFromBlock = require('../utils/extract-data-from-block');\n\nconst validateOffsetAndLength = require('../utils/validate-offset-and-length');\n\nconst rawContent = node => {\n  return function* (options = {}) {\n    const {\n      offset,\n      length\n    } = validateOffsetAndLength(node.length, options.offset, options.length);\n    yield extractDataFromBlock(node, 0, offset, offset + length);\n  };\n};\n\nconst resolve = async (cid, name, path, toResolve, resolve, depth, ipld) => {\n  if (toResolve.length) {\n    throw errCode(new Error(`No link named ${path} found in raw node ${cid.toBaseEncodedString()}`), 'ERR_NOT_FOUND');\n  }\n\n  const buf = await ipld.get(cid);\n  return {\n    entry: {\n      name,\n      path,\n      cid,\n      node: buf,\n      content: rawContent(buf),\n      depth\n    }\n  };\n};\n\nmodule.exports = resolve;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-unixfs-exporter/src/resolvers/raw.js"],"names":["errCode","require","extractDataFromBlock","validateOffsetAndLength","rawContent","node","options","offset","length","resolve","cid","name","path","toResolve","depth","ipld","Error","toBaseEncodedString","buf","get","entry","content","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,oBAAoB,GAAGD,OAAO,CAAC,kCAAD,CAApC;;AACA,MAAME,uBAAuB,GAAGF,OAAO,CAAC,qCAAD,CAAvC;;AAEA,MAAMG,UAAU,GAAIC,IAAD,IAAU;AAC3B,SAAO,WAAYC,OAAO,GAAG,EAAtB,EAA0B;AAC/B,UAAM;AACJC,MAAAA,MADI;AAEJC,MAAAA;AAFI,QAGFL,uBAAuB,CAACE,IAAI,CAACG,MAAN,EAAcF,OAAO,CAACC,MAAtB,EAA8BD,OAAO,CAACE,MAAtC,CAH3B;AAKA,UAAMN,oBAAoB,CAACG,IAAD,EAAO,CAAP,EAAUE,MAAV,EAAkBA,MAAM,GAAGC,MAA3B,CAA1B;AACD,GAPD;AAQD,CATD;;AAWA,MAAMC,OAAO,GAAG,OAAOC,GAAP,EAAYC,IAAZ,EAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCJ,OAAnC,EAA4CK,KAA5C,EAAmDC,IAAnD,KAA4D;AAC1E,MAAIF,SAAS,CAACL,MAAd,EAAsB;AACpB,UAAMR,OAAO,CAAC,IAAIgB,KAAJ,CAAW,iBAAgBJ,IAAK,sBAAqBF,GAAG,CAACO,mBAAJ,EAA0B,EAA/E,CAAD,EAAoF,eAApF,CAAb;AACD;;AAED,QAAMC,GAAG,GAAG,MAAMH,IAAI,CAACI,GAAL,CAAST,GAAT,CAAlB;AAEA,SAAO;AACLU,IAAAA,KAAK,EAAE;AACLT,MAAAA,IADK;AAELC,MAAAA,IAFK;AAGLF,MAAAA,GAHK;AAILL,MAAAA,IAAI,EAAEa,GAJD;AAKLG,MAAAA,OAAO,EAAEjB,UAAU,CAACc,GAAD,CALd;AAMLJ,MAAAA;AANK;AADF,GAAP;AAUD,CAjBD;;AAmBAQ,MAAM,CAACC,OAAP,GAAiBd,OAAjB","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst extractDataFromBlock = require('../utils/extract-data-from-block')\nconst validateOffsetAndLength = require('../utils/validate-offset-and-length')\n\nconst rawContent = (node) => {\n  return function * (options = {}) {\n    const {\n      offset,\n      length\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    yield extractDataFromBlock(node, 0, offset, offset + length)\n  }\n}\n\nconst resolve = async (cid, name, path, toResolve, resolve, depth, ipld) => {\n  if (toResolve.length) {\n    throw errCode(new Error(`No link named ${path} found in raw node ${cid.toBaseEncodedString()}`), 'ERR_NOT_FOUND')\n  }\n\n  const buf = await ipld.get(cid)\n\n  return {\n    entry: {\n      name,\n      path,\n      cid,\n      node: buf,\n      content: rawContent(buf),\n      depth\n    }\n  }\n}\n\nmodule.exports = resolve\n"]},"metadata":{},"sourceType":"script"}