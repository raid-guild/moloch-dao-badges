{"ast":null,"code":"/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\nfunction __values(o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n, f) {\n    i[n] = o[n] ? function (v) {\n      return (p = !p) ? {\n        value: __await(o[n](v)),\n        done: n === \"return\"\n      } : f ? f(v) : v;\n    } : f;\n  }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n}\n\nfunction _batch(size, iterable) {\n  return __asyncGenerator(this, arguments, function* _batch_1() {\n    var e_1, _a;\n\n    let dataBatch = [];\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const data = iterable_1_1.value;\n        dataBatch.push(data);\n\n        if (dataBatch.length === size) {\n          yield yield __await(dataBatch);\n          dataBatch = [];\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (dataBatch.length > 0) {\n      yield yield __await(dataBatch);\n    }\n  });\n}\n\nfunction* _syncBatch(size, iterable) {\n  let dataBatch = [];\n\n  for (const data of iterable) {\n    dataBatch.push(data);\n\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\n\nfunction batch(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batch(size, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _batch(size, iterable);\n  }\n\n  return _syncBatch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n  if (typeof iterable.next === 'function') {\n    return iterable;\n  }\n\n  if (typeof iterable[Symbol.iterator] === 'function') {\n    return iterable[Symbol.iterator]();\n  }\n\n  if (typeof iterable[Symbol.asyncIterator] === 'function') {\n    return iterable[Symbol.asyncIterator]();\n  }\n\n  throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n  let reject;\n  let resolve;\n  const promise = new Promise((resolveFunc, rejectFunc) => {\n    resolve = resolveFunc;\n    reject = rejectFunc;\n  });\n  return {\n    promise,\n    reject,\n    resolve\n  };\n} /// <reference lib=\"esnext.asynciterable\" />\n\n\nfunction _buffer(size, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let reading = false;\n  let ended = false;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const readDeferred = readQueue.shift();\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n\n      if (error) {\n        readDeferred.reject(error);\n      } else {\n        readDeferred.resolve({\n          done: false,\n          value\n        });\n      }\n    }\n\n    while (readQueue.length > 0 && ended) {\n      const {\n        resolve\n      } = readQueue.shift();\n      resolve({\n        done: true,\n        value: undefined\n      });\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (resultQueue.length >= size) {\n      return;\n    }\n\n    reading = true;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n      } else {\n        resultQueue.push({\n          value\n        });\n      }\n    } catch (error) {\n      ended = true;\n      resultQueue.push({\n        error\n      });\n    }\n\n    fulfillReadQueue();\n    reading = false;\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length > 0) {\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n\n      if (error) {\n        throw error;\n      }\n\n      fillQueue();\n      return {\n        done: false,\n        value\n      };\n    }\n\n    if (ended) {\n      return {\n        done: true,\n        value: undefined\n      }; // stupid ts\n    }\n\n    const deferred = defer();\n    readQueue.push(deferred);\n    fillQueue();\n    return deferred.promise;\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction* syncBuffer(size, iterable) {\n  const valueQueue = [];\n  let e;\n\n  try {\n    for (const value of iterable) {\n      valueQueue.push(value);\n\n      if (valueQueue.length <= size) {\n        continue;\n      }\n\n      yield valueQueue.shift();\n    }\n  } catch (error) {\n    e = error;\n  }\n\n  for (const value of valueQueue) {\n    yield value;\n  }\n\n  if (e) {\n    throw e;\n  }\n}\n\nfunction buffer(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => buffer(size, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _buffer(size, iterable);\n  }\n\n  return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n  var e_1, _a;\n\n  const values = [];\n\n  try {\n    for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n      const value = iterable_1_1.value;\n      values.push(value);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return values;\n}\n\nfunction collect(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _collect(iterable);\n  }\n\n  return Array.from(iterable);\n}\n\nfunction _concat(iterables) {\n  return __asyncGenerator(this, arguments, function* _concat_1() {\n    var e_1, _a;\n\n    try {\n      for (var iterables_1 = __asyncValues(iterables), iterables_1_1; iterables_1_1 = yield __await(iterables_1.next()), !iterables_1_1.done;) {\n        const iterable = iterables_1_1.value;\n        yield __await((yield* __asyncDelegator(__asyncValues(iterable))));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterables_1_1 && !iterables_1_1.done && (_a = iterables_1.return)) yield __await(_a.call(iterables_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction* _syncConcat(iterables) {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\nfunction concat(...iterables) {\n  const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n\n  if (hasAnyAsync) {\n    return _concat(iterables);\n  } else {\n    return _syncConcat(iterables);\n  }\n}\n\nasync function _consume(iterable) {\n  var e_1, _a;\n\n  try {\n    for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n      const val = iterable_1_1.value;\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n}\n\nfunction consume(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _consume(iterable);\n  }\n}\n\nfunction _filter(filterFunc, iterable) {\n  return __asyncGenerator(this, arguments, function* _filter_1() {\n    var e_1, _a;\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const data = iterable_1_1.value;\n\n        if (yield __await(filterFunc(data))) {\n          yield yield __await(data);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction filter(filterFunc, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _filter(filterFunc, curriedIterable);\n  }\n\n  return _filter(filterFunc, iterable);\n}\n\nfunction flatten(iterable) {\n  return __asyncGenerator(this, arguments, function* flatten_1() {\n    var e_1, _a;\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const maybeItr = iterable_1_1.value;\n\n        if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n          yield __await((yield* __asyncDelegator(__asyncValues(flatten(maybeItr)))));\n        } else {\n          yield yield __await(maybeItr);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction _map(func, iterable) {\n  return __asyncGenerator(this, arguments, function* _map_1() {\n    var e_1, _a;\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const val = iterable_1_1.value;\n        yield yield __await((yield __await(func(val))));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction map(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _map(func, curriedIterable);\n  }\n\n  return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => flatMap(func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    var e_1, _a;\n\n    try {\n      const value = await func(itrValue);\n\n      if (value && value[Symbol.asyncIterator]) {\n        try {\n          for (var _b = __asyncValues(value), _c; _c = await _b.next(), !_c.done;) {\n            const asyncVal = _c.value;\n            resultQueue.push(asyncVal);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } else {\n        resultQueue.push(value);\n      }\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction flatTransform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => flatTransform(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n  return new Promise(resolve => {\n    stream.once('readable', () => {\n      resolve();\n    });\n  });\n}\n\nfunction _fromStream(stream) {\n  return __asyncGenerator(this, arguments, function* _fromStream_1() {\n    while (true) {\n      const data = stream.read();\n\n      if (data !== null) {\n        yield yield __await(data);\n        continue;\n      }\n\n      if (stream._readableState.ended) {\n        return yield __await(void 0);\n      }\n\n      yield __await(onceReadable(stream));\n    }\n  });\n}\n\nfunction fromStream(stream) {\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return stream;\n  }\n\n  return _fromStream(stream);\n}\n\nfunction merge(...iterables) {\n  return __asyncGenerator(this, arguments, function* merge_1() {\n    const sources = new Set(iterables.map(getIterator));\n\n    while (sources.size > 0) {\n      for (const iterator of sources) {\n        const nextVal = yield __await(iterator.next());\n\n        if (nextVal.done) {\n          sources.delete(iterator);\n        } else {\n          yield yield __await(nextVal.value);\n        }\n      }\n    }\n  });\n}\n\nfunction pipeline(firstFn, ...fns) {\n  let previousFn = firstFn();\n\n  for (const func of fns) {\n    previousFn = func(previousFn);\n  }\n\n  return previousFn;\n}\n\nfunction _parallelMap(concurrency, func, iterable) {\n  return __asyncGenerator(this, arguments, function* _parallelMap_1() {\n    let transformError = null;\n\n    const wrapFunc = value => ({\n      value: func(value)\n    });\n\n    const stopOnError = function (source) {\n      return __asyncGenerator(this, arguments, function* () {\n        var e_1, _a;\n\n        try {\n          for (var source_1 = __asyncValues(source), source_1_1; source_1_1 = yield __await(source_1.next()), !source_1_1.done;) {\n            const value = source_1_1.value;\n\n            if (transformError) {\n              return yield __await(void 0);\n            }\n\n            yield yield __await(value);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield __await(_a.call(source_1));\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      });\n    };\n\n    const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency));\n    const itr = getIterator(output);\n\n    while (true) {\n      const {\n        value,\n        done\n      } = yield __await(itr.next());\n\n      if (done) {\n        break;\n      }\n\n      try {\n        const val = yield __await(value.value);\n\n        if (!transformError) {\n          yield yield __await(val);\n        }\n      } catch (error) {\n        transformError = error;\n      }\n    }\n\n    if (transformError) {\n      throw transformError;\n    }\n  });\n}\n\nfunction parallelMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n  }\n\n  return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelFlatMap(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\nfunction parallelMerge(...iterables) {\n  return __asyncGenerator(this, arguments, function* parallelMerge_1() {\n    const inputs = iterables.map(getIterator);\n    const concurrentWork = new Set();\n    const values = new Map();\n    let lastError = null;\n    let errCb = null;\n    let valueCb = null;\n\n    const notifyError = err => {\n      lastError = err;\n\n      if (errCb) {\n        errCb(err);\n      }\n    };\n\n    const notifyDone = value => {\n      if (valueCb) {\n        valueCb(value);\n      }\n    };\n\n    const waitForQueue = () => new Promise((resolve, reject) => {\n      if (lastError) {\n        reject(lastError);\n      }\n\n      if (values.size > 0) {\n        return resolve();\n      }\n\n      valueCb = resolve;\n      errCb = reject;\n    });\n\n    const queueNext = input => {\n      const nextVal = Promise.resolve(input.next()).then(async ({\n        done,\n        value\n      }) => {\n        if (!done) {\n          values.set(input, value);\n        }\n\n        concurrentWork.delete(nextVal);\n      });\n      concurrentWork.add(nextVal);\n      nextVal.then(notifyDone, notifyError);\n    };\n\n    for (const input of inputs) {\n      queueNext(input);\n    }\n\n    while (true) {\n      // We technically don't have to check `values.size` as the for loop should have emptied it\n      // However I haven't yet found specs verifying that behavior, only tests\n      // the guard in waitForQueue() checking for values is in place for the same reason\n      if (concurrentWork.size === 0 && values.size === 0) {\n        return yield __await(void 0);\n      }\n\n      yield __await(waitForQueue());\n\n      for (const [input, value] of values) {\n        values.delete(input);\n        yield yield __await(value);\n        queueNext(input);\n      }\n    }\n  });\n}\n\nasync function _reduce(func, start, iterable) {\n  var e_1, _a;\n\n  let value = start;\n\n  try {\n    for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n      const nextItem = iterable_1_1.value;\n      value = await func(value, nextItem);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return value;\n}\n\nfunction reduce(func, start, iterable) {\n  if (start === undefined) {\n    return (curriedStart, curriedIterable) => curriedIterable ? reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => reduce(func, start, curriedIterable);\n  }\n\n  return _reduce(func, start, iterable);\n}\n\nfunction _take(count, iterable) {\n  return __asyncGenerator(this, arguments, function* _take_1() {\n    var e_1, _a;\n\n    let taken = 0;\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const val = iterable_1_1.value;\n        yield yield __await((yield __await(val)));\n        taken++;\n\n        if (taken >= count) {\n          return yield __await(void 0);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction* _syncTake(count, iterable) {\n  let taken = 0;\n\n  for (const val of iterable) {\n    yield val;\n    taken++;\n\n    if (taken >= count) {\n      return;\n    }\n  }\n}\n\nfunction take(count, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => take(count, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _take(count, iterable);\n  }\n\n  return _syncTake(count, iterable);\n}\n\nfunction _asyncTap(func, iterable) {\n  return __asyncGenerator(this, arguments, function* _asyncTap_1() {\n    var e_1, _a;\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const val = iterable_1_1.value;\n        yield __await(func(val));\n        yield yield __await(val);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction tap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _asyncTap(func, curriedIterable);\n  }\n\n  return _asyncTap(func, iterable);\n}\n\nfunction addTime(a, b) {\n  let seconds = a[0] + b[0];\n  let nanoseconds = a[1] + b[1];\n\n  if (nanoseconds >= 1000000000) {\n    const remainder = nanoseconds % 1000000000;\n    seconds += (nanoseconds - remainder) / 1000000000;\n    nanoseconds = remainder;\n  }\n\n  return [seconds, nanoseconds];\n}\n\nfunction _asyncTime(config, iterable) {\n  return __asyncGenerator(this, arguments, function* _asyncTime_1() {\n    const itr = iterable[Symbol.asyncIterator]();\n    let total = [0, 0];\n\n    while (true) {\n      const start = process.hrtime();\n      const {\n        value,\n        done\n      } = yield __await(itr.next());\n      const delta = process.hrtime(start);\n      total = addTime(total, delta);\n\n      if (config.progress) {\n        config.progress(delta, total);\n      }\n\n      if (done) {\n        if (config.total) {\n          config.total(total);\n        }\n\n        return yield __await(value);\n      }\n\n      yield yield __await(value);\n    }\n  });\n}\n\nfunction* _syncTime(config, iterable) {\n  const itr = iterable[Symbol.iterator]();\n  let total = [0, 0];\n\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n\n      return value;\n    }\n\n    yield value;\n  }\n}\n\nfunction time(config = {}, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => time(config, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator] !== undefined) {\n    return _asyncTime(config, iterable);\n  } else {\n    return _syncTime(config, iterable);\n  }\n}\n\nfunction _transform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n      resultQueue.push(value);\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction transform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => transform(concurrency, func, curriedIterable);\n  }\n\n  return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n  var e_1, _a;\n\n  let lastError = null;\n  let errCb = null;\n  let drainCb = null;\n\n  const notifyError = err => {\n    lastError = err;\n\n    if (errCb) {\n      errCb(err);\n    }\n  };\n\n  const notifyDrain = () => {\n    if (drainCb) {\n      drainCb();\n    }\n  };\n\n  const cleanup = () => {\n    stream.removeListener('error', notifyError);\n    stream.removeListener('drain', notifyDrain);\n  };\n\n  stream.once('error', notifyError);\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      return reject(lastError);\n    }\n\n    stream.once('drain', notifyDrain);\n    drainCb = resolve;\n    errCb = reject;\n  });\n\n  try {\n    for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n      const value = iterable_1_1.value;\n\n      if (stream.write(value) === false) {\n        await waitForDrain();\n      }\n\n      if (lastError) {\n        break;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  cleanup();\n\n  if (lastError) {\n    throw lastError;\n  }\n}\n\nfunction writeToStream(stream, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _writeToStream(stream, curriedIterable);\n  }\n\n  return _writeToStream(stream, iterable);\n} /// <reference lib=\"esnext.asynciterable\" />\n\n\nif (Symbol.asyncIterator === undefined) {\n  Symbol.asyncIterator = Symbol.for('asyncIterator');\n}\n\nexport { batch, buffer, collect, concat, consume, filter, flatMap, flatten, flatTransform, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, time, transform, writeToStream };","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/streaming-iterables/dist/index-esm.js"],"names":["__values","o","m","Symbol","iterator","i","call","next","length","value","done","__await","v","__asyncGenerator","thisArg","_arguments","generator","asyncIterator","TypeError","g","apply","q","verb","n","Promise","a","b","push","resume","step","e","settle","r","resolve","then","fulfill","reject","f","shift","__asyncDelegator","p","__asyncValues","d","_batch","size","iterable","arguments","_batch_1","e_1","_a","dataBatch","iterable_1","iterable_1_1","data","e_1_1","error","return","_syncBatch","batch","undefined","curriedIterable","getIterator","defer","promise","resolveFunc","rejectFunc","_buffer","resultQueue","readQueue","reading","ended","fulfillReadQueue","readDeferred","fillQueue","deferred","asyncIterableIterator","syncBuffer","valueQueue","buffer","_collect","values","collect","Array","from","_concat","iterables","_concat_1","iterables_1","iterables_1_1","_syncConcat","concat","hasAnyAsync","find","itr","_consume","val","consume","_filter","filterFunc","_filter_1","filter","flatten","flatten_1","maybeItr","_map","func","_map_1","map","flatMap","_flatTransform","concurrency","inflightCount","lastError","mapAndQueue","itrValue","_b","_c","asyncVal","flatTransform","curriedFunc","onceReadable","stream","once","_fromStream","_fromStream_1","read","_readableState","fromStream","merge","merge_1","sources","Set","nextVal","delete","pipeline","firstFn","fns","previousFn","_parallelMap","_parallelMap_1","transformError","wrapFunc","stopOnError","source","source_1","source_1_1","output","parallelMap","parallelFlatMap","parallelMerge","parallelMerge_1","inputs","concurrentWork","Map","errCb","valueCb","notifyError","err","notifyDone","waitForQueue","queueNext","input","set","add","_reduce","start","nextItem","reduce","curriedStart","_take","count","_take_1","taken","_syncTake","take","_asyncTap","_asyncTap_1","tap","addTime","seconds","nanoseconds","remainder","_asyncTime","config","_asyncTime_1","total","process","hrtime","delta","progress","_syncTime","time","_transform","transform","_writeToStream","drainCb","notifyDrain","cleanup","removeListener","waitForDrain","write","writeToStream","for"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\n\nfunction _batch(size, iterable) {\n    return __asyncGenerator(this, arguments, function* _batch_1() {\n        var e_1, _a;\n        let dataBatch = [];\n        try {\n            for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n                const data = iterable_1_1.value;\n                dataBatch.push(data);\n                if (dataBatch.length === size) {\n                    yield yield __await(dataBatch);\n                    dataBatch = [];\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (dataBatch.length > 0) {\n            yield yield __await(dataBatch);\n        }\n    });\n}\nfunction* _syncBatch(size, iterable) {\n    let dataBatch = [];\n    for (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction batch(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batch(size, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _batch(size, iterable);\n    }\n    return _syncBatch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n    if (typeof iterable.next === 'function') {\n        return iterable;\n    }\n    if (typeof iterable[Symbol.iterator] === 'function') {\n        return iterable[Symbol.iterator]();\n    }\n    if (typeof iterable[Symbol.asyncIterator] === 'function') {\n        return iterable[Symbol.asyncIterator]();\n    }\n    throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n    let reject;\n    let resolve;\n    const promise = new Promise((resolveFunc, rejectFunc) => {\n        resolve = resolveFunc;\n        reject = rejectFunc;\n    });\n    return {\n        promise,\n        reject,\n        resolve,\n    };\n}\n\n/// <reference lib=\"esnext.asynciterable\" />\nfunction _buffer(size, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let reading = false;\n    let ended = false;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const readDeferred = readQueue.shift();\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                readDeferred.reject(error);\n            }\n            else {\n                readDeferred.resolve({ done: false, value });\n            }\n        }\n        while (readQueue.length > 0 && ended) {\n            const { resolve } = readQueue.shift();\n            resolve({ done: true, value: undefined });\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (resultQueue.length >= size) {\n            return;\n        }\n        reading = true;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n            }\n            else {\n                resultQueue.push({ value });\n            }\n        }\n        catch (error) {\n            ended = true;\n            resultQueue.push({ error });\n        }\n        fulfillReadQueue();\n        reading = false;\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length > 0) {\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                throw error;\n            }\n            fillQueue();\n            return { done: false, value };\n        }\n        if (ended) {\n            return { done: true, value: undefined }; // stupid ts\n        }\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction* syncBuffer(size, iterable) {\n    const valueQueue = [];\n    let e;\n    try {\n        for (const value of iterable) {\n            valueQueue.push(value);\n            if (valueQueue.length <= size) {\n                continue;\n            }\n            yield valueQueue.shift();\n        }\n    }\n    catch (error) {\n        e = error;\n    }\n    for (const value of valueQueue) {\n        yield value;\n    }\n    if (e) {\n        throw e;\n    }\n}\nfunction buffer(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => buffer(size, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _buffer(size, iterable);\n    }\n    return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n    var e_1, _a;\n    const values = [];\n    try {\n        for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n            const value = iterable_1_1.value;\n            values.push(value);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return values;\n}\nfunction collect(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _collect(iterable);\n    }\n    return Array.from(iterable);\n}\n\nfunction _concat(iterables) {\n    return __asyncGenerator(this, arguments, function* _concat_1() {\n        var e_1, _a;\n        try {\n            for (var iterables_1 = __asyncValues(iterables), iterables_1_1; iterables_1_1 = yield __await(iterables_1.next()), !iterables_1_1.done;) {\n                const iterable = iterables_1_1.value;\n                yield __await(yield* __asyncDelegator(__asyncValues(iterable)));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterables_1_1 && !iterables_1_1.done && (_a = iterables_1.return)) yield __await(_a.call(iterables_1));\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    });\n}\nfunction* _syncConcat(iterables) {\n    for (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction concat(...iterables) {\n    const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n    if (hasAnyAsync) {\n        return _concat(iterables);\n    }\n    else {\n        return _syncConcat(iterables);\n    }\n}\n\nasync function _consume(iterable) {\n    var e_1, _a;\n    try {\n        for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n            const val = iterable_1_1.value;\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\nfunction consume(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _consume(iterable);\n    }\n}\n\nfunction _filter(filterFunc, iterable) {\n    return __asyncGenerator(this, arguments, function* _filter_1() {\n        var e_1, _a;\n        try {\n            for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n                const data = iterable_1_1.value;\n                if (yield __await(filterFunc(data))) {\n                    yield yield __await(data);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    });\n}\nfunction filter(filterFunc, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _filter(filterFunc, curriedIterable);\n    }\n    return _filter(filterFunc, iterable);\n}\n\nfunction flatten(iterable) {\n    return __asyncGenerator(this, arguments, function* flatten_1() {\n        var e_1, _a;\n        try {\n            for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n                const maybeItr = iterable_1_1.value;\n                if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n                    yield __await(yield* __asyncDelegator(__asyncValues(flatten(maybeItr))));\n                }\n                else {\n                    yield yield __await(maybeItr);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    });\n}\n\nfunction _map(func, iterable) {\n    return __asyncGenerator(this, arguments, function* _map_1() {\n        var e_1, _a;\n        try {\n            for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n                const val = iterable_1_1.value;\n                yield yield __await(yield __await(func(val)));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    });\n}\nfunction map(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => _map(func, curriedIterable);\n    }\n    return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => flatMap(func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        var e_1, _a;\n        try {\n            const value = await func(itrValue);\n            if (value && value[Symbol.asyncIterator]) {\n                try {\n                    for (var _b = __asyncValues(value), _c; _c = await _b.next(), !_c.done;) {\n                        const asyncVal = _c.value;\n                        resultQueue.push(asyncVal);\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n            else {\n                resultQueue.push(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction flatTransform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? flatTransform(concurrency, curriedFunc, curriedIterable)\n            : flatTransform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n    return new Promise(resolve => {\n        stream.once('readable', () => {\n            resolve();\n        });\n    });\n}\nfunction _fromStream(stream) {\n    return __asyncGenerator(this, arguments, function* _fromStream_1() {\n        while (true) {\n            const data = stream.read();\n            if (data !== null) {\n                yield yield __await(data);\n                continue;\n            }\n            if (stream._readableState.ended) {\n                return yield __await(void 0);\n            }\n            yield __await(onceReadable(stream));\n        }\n    });\n}\nfunction fromStream(stream) {\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n        return stream;\n    }\n    return _fromStream(stream);\n}\n\nfunction merge(...iterables) {\n    return __asyncGenerator(this, arguments, function* merge_1() {\n        const sources = new Set(iterables.map(getIterator));\n        while (sources.size > 0) {\n            for (const iterator of sources) {\n                const nextVal = yield __await(iterator.next());\n                if (nextVal.done) {\n                    sources.delete(iterator);\n                }\n                else {\n                    yield yield __await(nextVal.value);\n                }\n            }\n        }\n    });\n}\n\nfunction pipeline(firstFn, ...fns) {\n    let previousFn = firstFn();\n    for (const func of fns) {\n        previousFn = func(previousFn);\n    }\n    return previousFn;\n}\n\nfunction _parallelMap(concurrency, func, iterable) {\n    return __asyncGenerator(this, arguments, function* _parallelMap_1() {\n        let transformError = null;\n        const wrapFunc = value => ({\n            value: func(value),\n        });\n        const stopOnError = function (source) {\n            return __asyncGenerator(this, arguments, function* () {\n                var e_1, _a;\n                try {\n                    for (var source_1 = __asyncValues(source), source_1_1; source_1_1 = yield __await(source_1.next()), !source_1_1.done;) {\n                        const value = source_1_1.value;\n                        if (transformError) {\n                            return yield __await(void 0);\n                        }\n                        yield yield __await(value);\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield __await(_a.call(source_1));\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            });\n        };\n        const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency));\n        const itr = getIterator(output);\n        while (true) {\n            const { value, done } = yield __await(itr.next());\n            if (done) {\n                break;\n            }\n            try {\n                const val = yield __await(value.value);\n                if (!transformError) {\n                    yield yield __await(val);\n                }\n            }\n            catch (error) {\n                transformError = error;\n            }\n        }\n        if (transformError) {\n            throw transformError;\n        }\n    });\n}\nfunction parallelMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n    }\n    if (iterable === undefined) {\n        return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n    }\n    return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? parallelFlatMap(concurrency, curriedFunc, curriedIterable)\n            : parallelFlatMap(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\nfunction parallelMerge(...iterables) {\n    return __asyncGenerator(this, arguments, function* parallelMerge_1() {\n        const inputs = iterables.map(getIterator);\n        const concurrentWork = new Set();\n        const values = new Map();\n        let lastError = null;\n        let errCb = null;\n        let valueCb = null;\n        const notifyError = err => {\n            lastError = err;\n            if (errCb) {\n                errCb(err);\n            }\n        };\n        const notifyDone = value => {\n            if (valueCb) {\n                valueCb(value);\n            }\n        };\n        const waitForQueue = () => new Promise((resolve, reject) => {\n            if (lastError) {\n                reject(lastError);\n            }\n            if (values.size > 0) {\n                return resolve();\n            }\n            valueCb = resolve;\n            errCb = reject;\n        });\n        const queueNext = input => {\n            const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {\n                if (!done) {\n                    values.set(input, value);\n                }\n                concurrentWork.delete(nextVal);\n            });\n            concurrentWork.add(nextVal);\n            nextVal.then(notifyDone, notifyError);\n        };\n        for (const input of inputs) {\n            queueNext(input);\n        }\n        while (true) {\n            // We technically don't have to check `values.size` as the for loop should have emptied it\n            // However I haven't yet found specs verifying that behavior, only tests\n            // the guard in waitForQueue() checking for values is in place for the same reason\n            if (concurrentWork.size === 0 && values.size === 0) {\n                return yield __await(void 0);\n            }\n            yield __await(waitForQueue());\n            for (const [input, value] of values) {\n                values.delete(input);\n                yield yield __await(value);\n                queueNext(input);\n            }\n        }\n    });\n}\n\nasync function _reduce(func, start, iterable) {\n    var e_1, _a;\n    let value = start;\n    try {\n        for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n            const nextItem = iterable_1_1.value;\n            value = await func(value, nextItem);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return value;\n}\nfunction reduce(func, start, iterable) {\n    if (start === undefined) {\n        return (curriedStart, curriedIterable) => curriedIterable ? reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => reduce(func, start, curriedIterable);\n    }\n    return _reduce(func, start, iterable);\n}\n\nfunction _take(count, iterable) {\n    return __asyncGenerator(this, arguments, function* _take_1() {\n        var e_1, _a;\n        let taken = 0;\n        try {\n            for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n                const val = iterable_1_1.value;\n                yield yield __await(yield __await(val));\n                taken++;\n                if (taken >= count) {\n                    return yield __await(void 0);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    });\n}\nfunction* _syncTake(count, iterable) {\n    let taken = 0;\n    for (const val of iterable) {\n        yield val;\n        taken++;\n        if (taken >= count) {\n            return;\n        }\n    }\n}\nfunction take(count, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => take(count, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _take(count, iterable);\n    }\n    return _syncTake(count, iterable);\n}\n\nfunction _asyncTap(func, iterable) {\n    return __asyncGenerator(this, arguments, function* _asyncTap_1() {\n        var e_1, _a;\n        try {\n            for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n                const val = iterable_1_1.value;\n                yield __await(func(val));\n                yield yield __await(val);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    });\n}\nfunction tap(func, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _asyncTap(func, curriedIterable);\n    }\n    return _asyncTap(func, iterable);\n}\n\nfunction addTime(a, b) {\n    let seconds = a[0] + b[0];\n    let nanoseconds = a[1] + b[1];\n    if (nanoseconds >= 1000000000) {\n        const remainder = nanoseconds % 1000000000;\n        seconds += (nanoseconds - remainder) / 1000000000;\n        nanoseconds = remainder;\n    }\n    return [seconds, nanoseconds];\n}\nfunction _asyncTime(config, iterable) {\n    return __asyncGenerator(this, arguments, function* _asyncTime_1() {\n        const itr = iterable[Symbol.asyncIterator]();\n        let total = [0, 0];\n        while (true) {\n            const start = process.hrtime();\n            const { value, done } = yield __await(itr.next());\n            const delta = process.hrtime(start);\n            total = addTime(total, delta);\n            if (config.progress) {\n                config.progress(delta, total);\n            }\n            if (done) {\n                if (config.total) {\n                    config.total(total);\n                }\n                return yield __await(value);\n            }\n            yield yield __await(value);\n        }\n    });\n}\nfunction* _syncTime(config, iterable) {\n    const itr = iterable[Symbol.iterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction time(config = {}, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => time(config, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] !== undefined) {\n        return _asyncTime(config, iterable);\n    }\n    else {\n        return _syncTime(config, iterable);\n    }\n}\n\nfunction _transform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            resultQueue.push(value);\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction transform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? transform(concurrency, curriedFunc, curriedIterable)\n            : transform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => transform(concurrency, func, curriedIterable);\n    }\n    return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n    var e_1, _a;\n    let lastError = null;\n    let errCb = null;\n    let drainCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDrain = () => {\n        if (drainCb) {\n            drainCb();\n        }\n    };\n    const cleanup = () => {\n        stream.removeListener('error', notifyError);\n        stream.removeListener('drain', notifyDrain);\n    };\n    stream.once('error', notifyError);\n    const waitForDrain = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            return reject(lastError);\n        }\n        stream.once('drain', notifyDrain);\n        drainCb = resolve;\n        errCb = reject;\n    });\n    try {\n        for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n            const value = iterable_1_1.value;\n            if (stream.write(value) === false) {\n                await waitForDrain();\n            }\n            if (lastError) {\n                break;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    cleanup();\n    if (lastError) {\n        throw lastError;\n    }\n}\nfunction writeToStream(stream, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _writeToStream(stream, curriedIterable);\n    }\n    return _writeToStream(stream, iterable);\n}\n\n/// <reference lib=\"esnext.asynciterable\" />\nif (Symbol.asyncIterator === undefined) {\n    Symbol.asyncIterator = Symbol.for('asyncIterator');\n}\n\nexport { batch, buffer, collect, concat, consume, filter, flatMap, flatten, flatTransform, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, time, transform, writeToStream };\n"]},"metadata":{},"sourceType":"module"}