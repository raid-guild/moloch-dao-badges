{"ast":null,"code":"'use strict';\n\nconst Identity = require('./identity');\n\nconst IdentityProvider = require('./identity-provider-interface.js');\n\nconst OrbitDBIdentityProvider = require('./orbit-db-identity-provider');\n\nconst Keystore = require('orbit-db-keystore');\n\nconst LRU = require('lru');\n\nconst path = require('path');\n\nconst defaultType = 'orbitdb';\nconst identityKeysPath = path.join('./orbitdb', 'identity', 'identitykeys');\nconst supportedTypes = {\n  orbitdb: OrbitDBIdentityProvider\n};\n\nconst getHandlerFor = type => {\n  if (!Identities.isSupported(type)) {\n    throw new Error(`IdentityProvider type '${type}' is not supported`);\n  }\n\n  return supportedTypes[type];\n};\n\nclass Identities {\n  constructor(options) {\n    this._keystore = options.keystore;\n    this._signingKeystore = options.signingKeystore || this._keystore;\n    this._knownIdentities = options.cache || new LRU(options.cacheSize || 100);\n  }\n\n  static get IdentityProvider() {\n    return IdentityProvider;\n  }\n\n  get keystore() {\n    return this._keystore;\n  }\n\n  get signingKeystore() {\n    return this._signingKeystore;\n  }\n\n  async sign(identity, data) {\n    const signingKey = await this.keystore.getKey(identity.id);\n\n    if (!signingKey) {\n      throw new Error(`Private signing key not found from Keystore`);\n    }\n\n    const sig = await this.keystore.sign(signingKey, data);\n    return sig;\n  }\n\n  async verify(signature, publicKey, data, verifier = 'v1') {\n    return this.keystore.verify(signature, publicKey, data, verifier);\n  }\n\n  async createIdentity(options = {}) {\n    const keystore = options.keystore || this.keystore;\n    const type = options.type || defaultType;\n    const identityProvider = type === defaultType ? new OrbitDBIdentityProvider(options.signingKeystore || keystore) : new (getHandlerFor(type))(options);\n    const id = await identityProvider.getId(options);\n\n    if (options.migrate) {\n      await options.migrate({\n        targetStore: keystore._store,\n        targetId: id\n      });\n    }\n\n    const {\n      publicKey,\n      idSignature\n    } = await this.signId(id);\n    const pubKeyIdSignature = await identityProvider.signIdentity(publicKey + idSignature, options);\n    return new Identity(id, publicKey, idSignature, pubKeyIdSignature, type, this);\n  }\n\n  async signId(id) {\n    const keystore = this.keystore;\n    const key = (await keystore.getKey(id)) || (await keystore.createKey(id));\n    const publicKey = keystore.getPublic(key);\n    const idSignature = await keystore.sign(key, id);\n    return {\n      publicKey,\n      idSignature\n    };\n  }\n\n  async verifyIdentity(identity) {\n    if (!Identity.isIdentity(identity)) {\n      return false;\n    }\n\n    const knownID = this._knownIdentities.get(identity.signatures.id);\n\n    if (knownID) {\n      return identity.id === knownID.id && identity.publicKey === knownID.publicKey && identity.signatures.id === knownID.signatures.id && identity.signatures.publicKey === knownID.signatures.publicKey;\n    }\n\n    const verifyIdSig = await this.keystore.verify(identity.signatures.id, identity.publicKey, identity.id);\n    if (!verifyIdSig) return false;\n    const IdentityProvider = getHandlerFor(identity.type);\n    const verified = await IdentityProvider.verifyIdentity(identity);\n\n    if (verified) {\n      this._knownIdentities.set(identity.signatures.id, Identity.toJSON(identity));\n    }\n\n    return verified;\n  }\n\n  static async verifyIdentity(identity) {\n    if (!Identity.isIdentity(identity)) {\n      return false;\n    }\n\n    const verifyIdSig = await Keystore.verify(identity.signatures.id, identity.publicKey, identity.id);\n    if (!verifyIdSig) return false;\n    const IdentityProvider = getHandlerFor(identity.type);\n    return IdentityProvider.verifyIdentity(identity);\n  }\n\n  static async createIdentity(options = {}) {\n    if (!options.keystore) {\n      options.keystore = new Keystore(options.identityKeysPath || identityKeysPath);\n    }\n\n    if (!options.signingKeystore) {\n      if (options.signingKeysPath) {\n        options.signingKeystore = new Keystore(options.signingKeysPath);\n      } else {\n        options.signingKeystore = options.keystore;\n      }\n    }\n\n    options = Object.assign({}, {\n      type: defaultType\n    }, options);\n    const identities = new Identities(options);\n    return identities.createIdentity(options);\n  }\n\n  static isSupported(type) {\n    return Object.keys(supportedTypes).includes(type);\n  }\n\n  static addIdentityProvider(IdentityProvider) {\n    if (!IdentityProvider) {\n      throw new Error('IdentityProvider class needs to be given as an option');\n    }\n\n    if (!IdentityProvider.type || typeof IdentityProvider.type !== 'string') {\n      throw new Error('Given IdentityProvider class needs to implement: static get type() { /* return a string */}.');\n    }\n\n    supportedTypes[IdentityProvider.type] = IdentityProvider;\n  }\n\n  static removeIdentityProvider(type) {\n    delete supportedTypes[type];\n  }\n\n}\n\nmodule.exports = Identities;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/orbit-db-identity-provider/src/identities.js"],"names":["Identity","require","IdentityProvider","OrbitDBIdentityProvider","Keystore","LRU","path","defaultType","identityKeysPath","join","supportedTypes","orbitdb","getHandlerFor","type","Identities","isSupported","Error","constructor","options","_keystore","keystore","_signingKeystore","signingKeystore","_knownIdentities","cache","cacheSize","sign","identity","data","signingKey","getKey","id","sig","verify","signature","publicKey","verifier","createIdentity","identityProvider","getId","migrate","targetStore","_store","targetId","idSignature","signId","pubKeyIdSignature","signIdentity","key","createKey","getPublic","verifyIdentity","isIdentity","knownID","get","signatures","verifyIdSig","verified","set","toJSON","signingKeysPath","Object","assign","identities","keys","includes","addIdentityProvider","removeIdentityProvider","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst Identity = require('./identity')\nconst IdentityProvider = require('./identity-provider-interface.js')\nconst OrbitDBIdentityProvider = require('./orbit-db-identity-provider')\nconst Keystore = require('orbit-db-keystore')\n\nconst LRU = require('lru')\nconst path = require('path')\n\nconst defaultType = 'orbitdb'\nconst identityKeysPath = path.join('./orbitdb', 'identity', 'identitykeys')\n\nconst supportedTypes = {\n  orbitdb: OrbitDBIdentityProvider\n}\n\nconst getHandlerFor = (type) => {\n  if (!Identities.isSupported(type)) {\n    throw new Error(`IdentityProvider type '${type}' is not supported`)\n  }\n  return supportedTypes[type]\n}\n\nclass Identities {\n  constructor (options) {\n    this._keystore = options.keystore\n    this._signingKeystore = options.signingKeystore || this._keystore\n    this._knownIdentities = options.cache || new LRU(options.cacheSize || 100)\n  }\n\n  static get IdentityProvider () { return IdentityProvider }\n\n  get keystore () { return this._keystore }\n\n  get signingKeystore () { return this._signingKeystore }\n\n  async sign (identity, data) {\n    const signingKey = await this.keystore.getKey(identity.id)\n    if (!signingKey) {\n      throw new Error(`Private signing key not found from Keystore`)\n    }\n    const sig = await this.keystore.sign(signingKey, data)\n    return sig\n  }\n\n  async verify (signature, publicKey, data, verifier = 'v1') {\n    return this.keystore.verify(signature, publicKey, data, verifier)\n  }\n\n  async createIdentity (options = {}) {\n    const keystore = options.keystore || this.keystore\n    const type = options.type || defaultType\n    const identityProvider = type === defaultType ? new OrbitDBIdentityProvider(options.signingKeystore || keystore) : new (getHandlerFor(type))(options)\n    const id = await identityProvider.getId(options)\n\n    if (options.migrate) {\n      await options.migrate({ targetStore: keystore._store, targetId: id })\n    }\n    const { publicKey, idSignature } = await this.signId(id)\n    const pubKeyIdSignature = await identityProvider.signIdentity(publicKey + idSignature, options)\n    return new Identity(id, publicKey, idSignature, pubKeyIdSignature, type, this)\n  }\n\n  async signId (id) {\n    const keystore = this.keystore\n    const key = await keystore.getKey(id) || await keystore.createKey(id)\n    const publicKey = keystore.getPublic(key)\n    const idSignature = await keystore.sign(key, id)\n    return { publicKey, idSignature }\n  }\n\n  async verifyIdentity (identity) {\n    if (!Identity.isIdentity(identity)) {\n      return false\n    }\n\n    const knownID = this._knownIdentities.get(identity.signatures.id)\n    if (knownID) {\n      return identity.id === knownID.id &&\n             identity.publicKey === knownID.publicKey &&\n             identity.signatures.id === knownID.signatures.id &&\n             identity.signatures.publicKey === knownID.signatures.publicKey\n    }\n\n    const verifyIdSig = await this.keystore.verify(\n      identity.signatures.id,\n      identity.publicKey,\n      identity.id\n    )\n    if (!verifyIdSig) return false\n\n    const IdentityProvider = getHandlerFor(identity.type)\n    const verified = await IdentityProvider.verifyIdentity(identity)\n    if (verified) {\n      this._knownIdentities.set(identity.signatures.id, Identity.toJSON(identity))\n    }\n\n    return verified\n  }\n\n  static async verifyIdentity (identity) {\n    if (!Identity.isIdentity(identity)) {\n      return false\n    }\n\n    const verifyIdSig = await Keystore.verify(\n      identity.signatures.id,\n      identity.publicKey,\n      identity.id\n    )\n\n    if (!verifyIdSig) return false\n\n    const IdentityProvider = getHandlerFor(identity.type)\n    return IdentityProvider.verifyIdentity(identity)\n  }\n\n  static async createIdentity (options = {}) {\n    if (!options.keystore) {\n      options.keystore = new Keystore(options.identityKeysPath || identityKeysPath)\n    }\n    if (!options.signingKeystore) {\n      if (options.signingKeysPath) {\n        options.signingKeystore = new Keystore(options.signingKeysPath)\n      } else {\n        options.signingKeystore = options.keystore\n      }\n    }\n    options = Object.assign({}, { type: defaultType }, options)\n    const identities = new Identities(options)\n    return identities.createIdentity(options)\n  }\n\n  static isSupported (type) {\n    return Object.keys(supportedTypes).includes(type)\n  }\n\n  static addIdentityProvider (IdentityProvider) {\n    if (!IdentityProvider) {\n      throw new Error('IdentityProvider class needs to be given as an option')\n    }\n\n    if (!IdentityProvider.type ||\n      typeof IdentityProvider.type !== 'string') {\n      throw new Error('Given IdentityProvider class needs to implement: static get type() { /* return a string */}.')\n    }\n\n    supportedTypes[IdentityProvider.type] = IdentityProvider\n  }\n\n  static removeIdentityProvider (type) {\n    delete supportedTypes[type]\n  }\n}\n\nmodule.exports = Identities\n"]},"metadata":{},"sourceType":"script"}