{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst Big = require('bignumber.js');\n\nconst MovingAverage = require('moving-average');\n\nclass Stats extends EventEmitter {\n  constructor(initialCounters, options) {\n    super();\n    this._options = options;\n    this._queue = [];\n    this._stats = {};\n    this._frequencyLastTime = Date.now();\n    this._frequencyAccumulators = {};\n    this._movingAverages = {};\n    this._update = this._update.bind(this);\n    initialCounters.forEach(key => {\n      this._stats[key] = Big(0);\n      this._movingAverages[key] = {};\n\n      this._options.movingAverageIntervals.forEach(interval => {\n        const ma = this._movingAverages[key][interval] = MovingAverage(interval);\n        ma.push(this._frequencyLastTime, 0);\n      });\n    });\n    this._enabled = this._options.enabled;\n  }\n\n  enable() {\n    this._enabled = true;\n  }\n\n  disable() {\n    this._disabled = true;\n  }\n\n  stop() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n  }\n\n  get snapshot() {\n    return Object.assign({}, this._stats);\n  }\n\n  get movingAverages() {\n    return Object.assign({}, this._movingAverages);\n  }\n\n  push(counter, inc) {\n    if (this._enabled) {\n      this._queue.push([counter, inc, Date.now()]);\n\n      this._resetComputeTimeout();\n    }\n  }\n\n  _resetComputeTimeout() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n\n    this._timeout = setTimeout(this._update, this._nextTimeout());\n  }\n\n  _nextTimeout() {\n    // calculate the need for an update, depending on the queue length\n    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;\n    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);\n  }\n\n  _update() {\n    this._timeout = null;\n\n    if (this._queue.length) {\n      let last;\n\n      while (this._queue.length) {\n        const op = last = this._queue.shift();\n\n        this._applyOp(op);\n      }\n\n      this._updateFrequency(last[2]); // contains timestamp of last op\n\n\n      this.emit('update', this._stats);\n    }\n  }\n\n  _updateFrequency(latestTime) {\n    const timeDiff = latestTime - this._frequencyLastTime;\n    Object.keys(this._stats).forEach(key => {\n      this._updateFrequencyFor(key, timeDiff, latestTime);\n    });\n    this._frequencyLastTime = latestTime;\n  }\n\n  _updateFrequencyFor(key, timeDiffMS, latestTime) {\n    const count = this._frequencyAccumulators[key] || 0;\n    this._frequencyAccumulators[key] = 0;\n    const hz = count / timeDiffMS * 1000;\n    let movingAverages = this._movingAverages[key];\n\n    if (!movingAverages) {\n      movingAverages = this._movingAverages[key] = {};\n    }\n\n    this._options.movingAverageIntervals.forEach(movingAverageInterval => {\n      let movingAverage = movingAverages[movingAverageInterval];\n\n      if (!movingAverage) {\n        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);\n      }\n\n      movingAverage.push(latestTime, hz);\n    });\n  }\n\n  _applyOp(op) {\n    const key = op[0];\n    const inc = op[1];\n\n    if (typeof inc !== 'number') {\n      throw new Error('invalid increment number:', inc);\n    }\n\n    let n;\n\n    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n      n = this._stats[key] = Big(0);\n    } else {\n      n = this._stats[key];\n    }\n\n    this._stats[key] = n.plus(inc);\n\n    if (!this._frequencyAccumulators[key]) {\n      this._frequencyAccumulators[key] = 0;\n    }\n\n    this._frequencyAccumulators[key] += inc;\n  }\n\n}\n\nmodule.exports = Stats;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs-bitswap/src/stats/stat.js"],"names":["EventEmitter","require","Big","MovingAverage","Stats","constructor","initialCounters","options","_options","_queue","_stats","_frequencyLastTime","Date","now","_frequencyAccumulators","_movingAverages","_update","bind","forEach","key","movingAverageIntervals","interval","ma","push","_enabled","enabled","enable","disable","_disabled","stop","_timeout","clearTimeout","snapshot","Object","assign","movingAverages","counter","inc","_resetComputeTimeout","setTimeout","_nextTimeout","urgency","length","computeThrottleMaxQueueSize","Math","max","computeThrottleTimeout","last","op","shift","_applyOp","_updateFrequency","emit","latestTime","timeDiff","keys","_updateFrequencyFor","timeDiffMS","count","hz","movingAverageInterval","movingAverage","Error","n","prototype","hasOwnProperty","call","plus","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\nconst Big = require('bignumber.js')\nconst MovingAverage = require('moving-average')\n\nclass Stats extends EventEmitter {\n  constructor (initialCounters, options) {\n    super()\n\n    this._options = options\n    this._queue = []\n    this._stats = {}\n\n    this._frequencyLastTime = Date.now()\n    this._frequencyAccumulators = {}\n    this._movingAverages = {}\n\n    this._update = this._update.bind(this)\n\n    initialCounters.forEach((key) => {\n      this._stats[key] = Big(0)\n      this._movingAverages[key] = {}\n      this._options.movingAverageIntervals.forEach((interval) => {\n        const ma = this._movingAverages[key][interval] = MovingAverage(interval)\n        ma.push(this._frequencyLastTime, 0)\n      })\n    })\n\n    this._enabled = this._options.enabled\n  }\n\n  enable () {\n    this._enabled = true\n  }\n\n  disable () {\n    this._disabled = true\n  }\n\n  stop () {\n    if (this._timeout) {\n      clearTimeout(this._timeout)\n    }\n  }\n\n  get snapshot () {\n    return Object.assign({}, this._stats)\n  }\n\n  get movingAverages () {\n    return Object.assign({}, this._movingAverages)\n  }\n\n  push (counter, inc) {\n    if (this._enabled) {\n      this._queue.push([counter, inc, Date.now()])\n      this._resetComputeTimeout()\n    }\n  }\n\n  _resetComputeTimeout () {\n    if (this._timeout) {\n      clearTimeout(this._timeout)\n    }\n    this._timeout = setTimeout(this._update, this._nextTimeout())\n  }\n\n  _nextTimeout () {\n    // calculate the need for an update, depending on the queue length\n    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize\n    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0)\n  }\n\n  _update () {\n    this._timeout = null\n\n    if (this._queue.length) {\n      let last\n      while (this._queue.length) {\n        const op = last = this._queue.shift()\n        this._applyOp(op)\n      }\n\n      this._updateFrequency(last[2]) // contains timestamp of last op\n\n      this.emit('update', this._stats)\n    }\n  }\n\n  _updateFrequency (latestTime) {\n    const timeDiff = latestTime - this._frequencyLastTime\n\n    Object.keys(this._stats).forEach((key) => {\n      this._updateFrequencyFor(key, timeDiff, latestTime)\n    })\n\n    this._frequencyLastTime = latestTime\n  }\n\n  _updateFrequencyFor (key, timeDiffMS, latestTime) {\n    const count = this._frequencyAccumulators[key] || 0\n    this._frequencyAccumulators[key] = 0\n    const hz = (count / timeDiffMS) * 1000\n\n    let movingAverages = this._movingAverages[key]\n    if (!movingAverages) {\n      movingAverages = this._movingAverages[key] = {}\n    }\n    this._options.movingAverageIntervals.forEach((movingAverageInterval) => {\n      let movingAverage = movingAverages[movingAverageInterval]\n      if (!movingAverage) {\n        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval)\n      }\n      movingAverage.push(latestTime, hz)\n    })\n  }\n\n  _applyOp (op) {\n    const key = op[0]\n    const inc = op[1]\n\n    if (typeof inc !== 'number') {\n      throw new Error('invalid increment number:', inc)\n    }\n\n    let n\n\n    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n      n = this._stats[key] = Big(0)\n    } else {\n      n = this._stats[key]\n    }\n    this._stats[key] = n.plus(inc)\n\n    if (!this._frequencyAccumulators[key]) {\n      this._frequencyAccumulators[key] = 0\n    }\n    this._frequencyAccumulators[key] += inc\n  }\n}\n\nmodule.exports = Stats\n"]},"metadata":{},"sourceType":"script"}