{"ast":null,"code":"'use strict';\n\nmodule.exports = function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {\n  const blockLength = block.length;\n  const blockEnd = blockStart + blockLength;\n\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return Buffer.alloc(0);\n  }\n\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.slice(0, requestedEnd - blockStart);\n  }\n\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.slice(requestedStart - blockStart);\n  }\n\n  return block;\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.js"],"names":["module","exports","extractDataFromBlock","block","blockStart","requestedStart","requestedEnd","blockLength","length","blockEnd","Buffer","alloc","slice"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,SAASC,oBAAT,CAA+BC,KAA/B,EAAsCC,UAAtC,EAAkDC,cAAlD,EAAkEC,YAAlE,EAAgF;AAC/F,QAAMC,WAAW,GAAGJ,KAAK,CAACK,MAA1B;AACA,QAAMC,QAAQ,GAAGL,UAAU,GAAGG,WAA9B;;AAEA,MAAIF,cAAc,IAAII,QAAlB,IAA8BH,YAAY,GAAGF,UAAjD,EAA6D;AAC3D;AACA;AACA,WAAOM,MAAM,CAACC,KAAP,CAAa,CAAb,CAAP;AACD;;AAED,MAAIL,YAAY,IAAIF,UAAhB,IAA8BE,YAAY,GAAGG,QAAjD,EAA2D;AACzD;AACAN,IAAAA,KAAK,GAAGA,KAAK,CAACS,KAAN,CAAY,CAAZ,EAAeN,YAAY,GAAGF,UAA9B,CAAR;AACD;;AAED,MAAIC,cAAc,IAAID,UAAlB,IAAgCC,cAAc,GAAGI,QAArD,EAA+D;AAC7D;AACAN,IAAAA,KAAK,GAAGA,KAAK,CAACS,KAAN,CAAYP,cAAc,GAAGD,UAA7B,CAAR;AACD;;AAED,SAAOD,KAAP;AACD,CArBD","sourcesContent":["'use strict'\n\nmodule.exports = function extractDataFromBlock (block, blockStart, requestedStart, requestedEnd) {\n  const blockLength = block.length\n  const blockEnd = blockStart + blockLength\n\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return Buffer.alloc(0)\n  }\n\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.slice(0, requestedEnd - blockStart)\n  }\n\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.slice(requestedStart - blockStart)\n  }\n\n  return block\n}\n"]},"metadata":{},"sourceType":"script"}