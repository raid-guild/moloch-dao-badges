{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst protons = require('protons');\n\nconst proto = protons(require('./dag.proto.js'));\n\nconst DAGLink = require('./dag-link');\n\nconst DAGNode = require('./dag-node');\n\nconst multicodec = require('multicodec');\n\nconst multihashing = require('multihashing-async');\n\nexports = module.exports;\nexports.codec = multicodec.DAG_PB;\nexports.defaultHashAlg = multicodec.SHA2_256;\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\n\nconst cid = async (binaryBlob, userOptions) => {\n  const defaultOptions = {\n    cidVersion: 1,\n    hashAlg: exports.defaultHashAlg\n  };\n  const options = Object.assign(defaultOptions, userOptions);\n  const multihash = await multihashing(binaryBlob, options.hashAlg);\n  const codecName = multicodec.print[exports.codec];\n  const cid = new CID(options.cidVersion, codecName, multihash);\n  return cid;\n};\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Buffer} - The encoded binary representation\n */\n\n\nconst serialize = node => {\n  let data = node.Data;\n  let links = node.Links || []; // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n\n  if (!DAGNode.isDAGNode(node) && links) {\n    links = links.map(link => {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);\n    });\n  }\n\n  const serialized = proto.PBNode.encode(toProtoBuf({\n    Data: data,\n    Links: links\n  }));\n  return serialized;\n};\n/**\n * Deserialize PB block into the internal representation.\n *\n * @param {Buffer} buffer - Binary representation of a PB block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\n\n\nconst deserialize = buffer => {\n  const pbn = proto.PBNode.decode(buffer);\n  const links = pbn.Links.map(link => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash);\n  });\n  const data = pbn.Data == null ? Buffer.alloc(0) : pbn.Data;\n  return new DAGNode(data, links, buffer.length);\n};\n\nfunction toProtoBuf(node) {\n  const pbn = {};\n\n  if (node.Data && node.Data.length > 0) {\n    pbn.Data = node.Data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null;\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links.map(link => ({\n      Hash: link.Hash.buffer,\n      Name: link.Name,\n      Tsize: link.Tsize\n    }));\n  } else {\n    pbn.Links = null;\n  }\n\n  return pbn;\n}\n\nexports.serialize = serialize;\nexports.deserialize = deserialize;\nexports.cid = cid;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/orbit-db-access-controllers/node_modules/ipld-dag-pb/src/util.js"],"names":["CID","require","protons","proto","DAGLink","DAGNode","multicodec","multihashing","exports","module","codec","DAG_PB","defaultHashAlg","SHA2_256","cid","binaryBlob","userOptions","defaultOptions","cidVersion","hashAlg","options","Object","assign","multihash","codecName","print","serialize","node","data","Data","links","Links","isDAGNode","map","link","isDAGLink","util","createDagLinkFromB58EncodedHash","serialized","PBNode","encode","toProtoBuf","deserialize","buffer","pbn","decode","Name","Tsize","Hash","Buffer","alloc","length"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst protons = require('protons')\nconst proto = protons(require('./dag.proto.js'))\nconst DAGLink = require('./dag-link')\nconst DAGNode = require('./dag-node')\nconst multicodec = require('multicodec')\nconst multihashing = require('multihashing-async')\n\nexports = module.exports\n\nexports.codec = multicodec.DAG_PB\nexports.defaultHashAlg = multicodec.SHA2_256\n\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\nconst cid = async (binaryBlob, userOptions) => {\n  const defaultOptions = { cidVersion: 1, hashAlg: exports.defaultHashAlg }\n  const options = Object.assign(defaultOptions, userOptions)\n\n  const multihash = await multihashing(binaryBlob, options.hashAlg)\n  const codecName = multicodec.print[exports.codec]\n  const cid = new CID(options.cidVersion, codecName, multihash)\n\n  return cid\n}\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Buffer} - The encoded binary representation\n */\nconst serialize = (node) => {\n  let data = node.Data\n  let links = node.Links || []\n\n  // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n  if (!DAGNode.isDAGNode(node) && links) {\n    links = links.map((link) => {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link)\n    })\n  }\n\n  const serialized = proto.PBNode.encode(toProtoBuf({\n    Data: data,\n    Links: links\n  }))\n\n  return serialized\n}\n\n/**\n * Deserialize PB block into the internal representation.\n *\n * @param {Buffer} buffer - Binary representation of a PB block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\nconst deserialize = (buffer) => {\n  const pbn = proto.PBNode.decode(buffer)\n\n  const links = pbn.Links.map((link) => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash)\n  })\n\n  const data = pbn.Data == null ? Buffer.alloc(0) : pbn.Data\n\n  return new DAGNode(data, links, buffer.length)\n}\n\nfunction toProtoBuf (node) {\n  const pbn = {}\n\n  if (node.Data && node.Data.length > 0) {\n    pbn.Data = node.Data\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links\n      .map((link) => ({\n        Hash: link.Hash.buffer,\n        Name: link.Name,\n        Tsize: link.Tsize\n      }))\n  } else {\n    pbn.Links = null\n  }\n\n  return pbn\n}\n\nexports.serialize = serialize\nexports.deserialize = deserialize\nexports.cid = cid\n"]},"metadata":{},"sourceType":"script"}