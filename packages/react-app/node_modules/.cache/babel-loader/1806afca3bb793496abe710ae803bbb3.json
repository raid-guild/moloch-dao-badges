{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst EventStore = require('orbit-db-eventstore');\n\nconst FeedStore = require('orbit-db-feedstore');\n\nconst KeyValueStore = require('orbit-db-kvstore');\n\nconst CounterStore = require('orbit-db-counterstore');\n\nconst DocumentStore = require('orbit-db-docstore');\n\nconst Pubsub = require('orbit-db-pubsub');\n\nconst Cache = require('orbit-db-cache');\n\nconst Keystore = require('orbit-db-keystore');\n\nconst Identities = require('orbit-db-identity-provider');\n\nlet AccessControllers = require('orbit-db-access-controllers');\n\nconst OrbitDBAddress = require('./orbit-db-address');\n\nconst createDBManifest = require('./db-manifest');\n\nconst exchangeHeads = require('./exchange-heads');\n\nconst {\n  isDefined,\n  io\n} = require('./utils');\n\nconst Storage = require('orbit-db-storage-adapter');\n\nconst migrations = require('./migrations');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create('orbit-db');\nLogger.setLogLevel('ERROR'); // Mapping for 'database type' -> Class\n\nconst databaseTypes = {\n  counter: CounterStore,\n  eventlog: EventStore,\n  feed: FeedStore,\n  docstore: DocumentStore,\n  keyvalue: KeyValueStore\n};\n\nclass OrbitDB {\n  constructor(ipfs, identity, options = {}) {\n    if (!isDefined(ipfs)) {\n      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    if (!isDefined(identity)) {\n      throw new Error('identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    this._ipfs = ipfs;\n    this.identity = identity;\n    this.id = options.peerId;\n    this._pubsub = !options.offline ? options.broker ? new options.broker(this._ipfs) // eslint-disable-line\n    : new Pubsub(this._ipfs, this.id) : null;\n    this.directory = options.directory || './orbitdb';\n    this.storage = options.storage;\n    this._directConnections = {};\n    this.caches = {};\n    this.caches[this.directory] = {\n      cache: options.cache,\n      handlers: new Set()\n    };\n    this.keystore = options.keystore;\n    this.stores = {}; // AccessControllers module can be passed in to enable\n    // testing with orbit-db-access-controller\n\n    AccessControllers = options.AccessControllers || AccessControllers;\n  }\n\n  static get Pubsub() {\n    return Pubsub;\n  }\n\n  static get Cache() {\n    return Cache;\n  }\n\n  static get Keystore() {\n    return Keystore;\n  }\n\n  static get Identities() {\n    return Identities;\n  }\n\n  static get AccessControllers() {\n    return AccessControllers;\n  }\n\n  static get Storage() {\n    return Storage;\n  }\n\n  static get OrbitDBAddress() {\n    return OrbitDBAddress;\n  }\n\n  static get EventStore() {\n    return EventStore;\n  }\n\n  static get FeedStore() {\n    return FeedStore;\n  }\n\n  static get KeyValueStore() {\n    return KeyValueStore;\n  }\n\n  static get CounterStore() {\n    return CounterStore;\n  }\n\n  static get DocumentStore() {\n    return DocumentStore;\n  }\n\n  get cache() {\n    return this.caches[this.directory].cache;\n  }\n\n  static async createInstance(ipfs, options = {}) {\n    if (!isDefined(ipfs)) {\n      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    if (options.offline === undefined) {\n      options.offline = false;\n    }\n\n    if (options.offline && !options.id) {\n      throw new Error('Offline mode requires passing an `id` in the options');\n    }\n\n    const {\n      id\n    } = options.offline ? {\n      id: options.id\n    } : await ipfs.id();\n\n    if (!options.directory) {\n      options.directory = './orbitdb';\n    }\n\n    if (!options.storage) {\n      const storageOptions = {}; // Create default `level` store\n\n      options.storage = Storage(null, storageOptions);\n    }\n\n    if (options.identity && options.identity.provider.keystore) {\n      options.keystore = options.identity.provider.keystore;\n    }\n\n    if (!options.keystore) {\n      const keystorePath = path.join(options.directory, id, '/keystore');\n      const keyStorage = await options.storage.createStore(keystorePath);\n      options.keystore = new Keystore(keyStorage);\n    }\n\n    if (!options.identity) {\n      options.identity = await Identities.createIdentity({\n        id: options.id || id,\n        keystore: options.keystore\n      });\n    }\n\n    if (!options.cache) {\n      const cachePath = path.join(options.directory, id, '/cache');\n      const cacheStorage = await options.storage.createStore(cachePath);\n      options.cache = new Cache(cacheStorage);\n    }\n\n    const finalOptions = Object.assign({}, options, {\n      peerId: id\n    });\n    return new OrbitDB(ipfs, options.identity, finalOptions);\n  }\n  /* Databases */\n\n\n  async feed(address, options = {}) {\n    options = Object.assign({\n      create: true,\n      type: 'feed'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async log(address, options = {}) {\n    options = Object.assign({\n      create: true,\n      type: 'eventlog'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async eventlog(address, options = {}) {\n    return this.log(address, options);\n  }\n\n  async keyvalue(address, options = {}) {\n    options = Object.assign({\n      create: true,\n      type: 'keyvalue'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async kvstore(address, options = {}) {\n    return this.keyvalue(address, options);\n  }\n\n  async counter(address, options = {}) {\n    options = Object.assign({\n      create: true,\n      type: 'counter'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async docs(address, options = {}) {\n    options = Object.assign({\n      create: true,\n      type: 'docstore'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async docstore(address, options = {}) {\n    return this.docs(address, options);\n  }\n\n  async disconnect() {\n    // close keystore\n    await this.keystore.close(); // Close all open databases\n\n    const databases = Object.values(this.stores);\n\n    for (const db of databases) {\n      await db.close();\n      delete this.stores[db.address.toString()];\n    }\n\n    const caches = Object.keys(this.caches);\n\n    for (const directory of caches) {\n      await this.caches[directory].cache.close();\n      delete this.caches[directory];\n    } // Close a direct connection and remove it from internal state\n\n\n    const removeDirectConnect = e => {\n      this._directConnections[e].close();\n\n      delete this._directConnections[e];\n    }; // Close all direct connections to peers\n\n\n    Object.keys(this._directConnections).forEach(removeDirectConnect); // Disconnect from pubsub\n\n    if (this._pubsub) {\n      await this._pubsub.disconnect();\n    } // Remove all databases from the state\n\n\n    this.stores = {};\n  } // Alias for disconnect()\n\n\n  async stop() {\n    await this.disconnect();\n  }\n\n  async _createCache(path) {\n    const cacheStorage = await this.storage.createStore(path);\n    return new Cache(cacheStorage);\n  }\n  /* Private methods */\n\n\n  async _createStore(type, address, options) {\n    // Get the type -> class mapping\n    const Store = databaseTypes[type];\n\n    if (!Store) {\n      throw new Error(`Invalid database type '${type}'`);\n    }\n\n    let accessController;\n\n    if (options.accessControllerAddress) {\n      accessController = await AccessControllers.resolve(this, options.accessControllerAddress, options.accessController);\n    }\n\n    const opts = Object.assign({\n      replicate: true\n    }, options, {\n      accessController: accessController,\n      cache: options.cache,\n      onClose: this._onClose.bind(this),\n      onDrop: this._onDrop.bind(this),\n      onLoad: this._onLoad.bind(this)\n    });\n    const identity = options.identity || this.identity;\n    const store = new Store(this._ipfs, identity, address, opts);\n    store.events.on('write', this._onWrite.bind(this)); // ID of the store is the address as a string\n\n    const addr = address.toString();\n    this.stores[addr] = store; // Subscribe to pubsub to get updates from peers,\n    // this is what hooks us into the message propagation layer\n    // and the p2p network\n\n    if (opts.replicate && this._pubsub) {\n      await this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this));\n    }\n\n    return store;\n  } // Callback for local writes to the database. We the update to pubsub.\n\n\n  _onWrite(address, entry, heads) {\n    if (!heads) throw new Error(\"'heads' not defined\");\n    if (this._pubsub) this._pubsub.publish(address, heads);\n  } // Callback for receiving a message from the network\n\n\n  async _onMessage(address, heads) {\n    const store = this.stores[address];\n\n    try {\n      logger.debug(`Received ${heads.length} heads for '${address}':\\n`, JSON.stringify(heads.map(e => e.hash), null, 2));\n\n      if (store && heads && heads.length > 0) {\n        await store.sync(heads);\n      }\n    } catch (e) {\n      logger.error(e);\n    }\n  } // Callback for when a peer connected to a database\n\n\n  async _onPeerConnected(address, peer) {\n    logger.debug(`New peer '${peer}' connected to '${address}'`);\n\n    const getStore = address => this.stores[address];\n\n    const getDirectConnection = peer => this._directConnections[peer];\n\n    const onChannelCreated = channel => {\n      this._directConnections[channel._receiverID] = channel;\n    };\n\n    const onMessage = (address, heads) => this._onMessage(address, heads);\n\n    await exchangeHeads(this._ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated);\n\n    if (getStore(address)) {\n      getStore(address).events.emit('peer', peer);\n    }\n  } // Callback when database was closed\n\n\n  async _onClose(db) {\n    const address = db.address.toString();\n    logger.debug(`Close ${address}`); // Unsubscribe from pubsub\n\n    if (this._pubsub) {\n      await this._pubsub.unsubscribe(address);\n    }\n\n    const store = this.stores[address];\n    const dir = store && store.options.directory ? store.options.directory : this.directory;\n    const cache = this.caches[dir];\n\n    if (cache && cache.handlers.has(address)) {\n      cache.handlers.delete(address);\n      if (!cache.handlers.size) await cache.cache.close();\n    }\n\n    delete this.stores[address];\n  }\n\n  async _onDrop(db) {\n    const address = db.address.toString();\n    const dir = db && db.options.directory ? db.options.directory : this.directory;\n    await this._requestCache(address, dir, db._cache);\n    this.stores[address] = db;\n  }\n\n  async _onLoad(db) {\n    const address = db.address.toString();\n    const dir = db && db.options.directory ? db.options.directory : this.directory;\n    await this._requestCache(address, dir, db._cache);\n    this.stores[address] = db;\n  }\n\n  async _determineAddress(name, type, options = {}) {\n    if (!OrbitDB.isValidType(type)) {\n      throw new Error(`Invalid database type '${type}'`);\n    }\n\n    if (OrbitDBAddress.isValid(name)) {\n      throw new Error('Given database name is an address. Please give only the name of the database!');\n    } // Create an AccessController, use IPFS AC as the default\n\n\n    options.accessController = Object.assign({}, {\n      name: name,\n      type: 'ipfs'\n    }, options.accessController);\n    const accessControllerAddress = await AccessControllers.create(this, options.accessController.type, options.accessController || {}); // Save the manifest to IPFS\n\n    const manifestHash = await createDBManifest(this._ipfs, name, type, accessControllerAddress, options); // Create the database address\n\n    return OrbitDBAddress.parse(OrbitDBAddress.join(manifestHash, name));\n  }\n  /* Create and Open databases */\n\n  /*\n    options = {\n      accessController: { write: [] } // array of keys that can write to this database\n      overwrite: false, // whether we should overwrite the existing database if it exists\n    }\n  */\n\n\n  async create(name, type, options = {}) {\n    logger.debug('create()');\n    logger.debug(`Creating database '${name}' as ${type}`); // Create the database address\n\n    const dbAddress = await this._determineAddress(name, type, options);\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory); // Check if we have the database locally\n\n    const haveDB = await this._haveLocalData(options.cache, dbAddress);\n\n    if (haveDB && !options.overwrite) {\n      throw new Error(`Database '${dbAddress}' already exists!`);\n    }\n\n    await this._migrate(options, dbAddress); // Save the database locally\n\n    await this._addManifestToCache(options.cache, dbAddress);\n    logger.debug(`Created database '${dbAddress}'`); // Open the database\n\n    return this.open(dbAddress, options);\n  }\n\n  async determineAddress(name, type, options = {}) {\n    const opts = Object.assign({}, {\n      onlyHash: true\n    }, options);\n    return this._determineAddress(name, type, opts);\n  }\n\n  async _requestCache(address, directory, existingCache) {\n    const dir = directory || this.directory;\n\n    if (!this.caches[dir]) {\n      const newCache = existingCache || (await this._createCache(dir));\n      this.caches[dir] = {\n        cache: newCache,\n        handlers: new Set()\n      };\n    }\n\n    this.caches[dir].handlers.add(address);\n    const cache = this.caches[dir].cache; // \"Wake up\" the caches if they need it\n\n    if (cache) await cache.open();\n    return cache;\n  }\n  /*\n      options = {\n        localOnly: false // if set to true, throws an error if database can't be found locally\n        create: false // whether to create the database\n        type: TODO\n        overwrite: TODO\n       }\n   */\n\n\n  async open(address, options = {}) {\n    logger.debug('open()');\n    options = Object.assign({\n      localOnly: false,\n      create: false\n    }, options);\n    logger.debug(`Open database '${address}'`); // If address is just the name of database, check the options to crate the database\n\n    if (!OrbitDBAddress.isValid(address)) {\n      if (!options.create) {\n        throw new Error('\\'options.create\\' set to \\'false\\'. If you want to create a database, set \\'options.create\\' to \\'true\\'.');\n      } else if (options.create && !options.type) {\n        throw new Error(`Database type not provided! Provide a type with 'options.type' (${OrbitDB.databaseTypes.join('|')})`);\n      } else {\n        logger.warn(`Not a valid OrbitDB address '${address}', creating the database`);\n        options.overwrite = options.overwrite ? options.overwrite : true;\n        return this.create(address, options.type, options);\n      }\n    } // Parse the database address\n\n\n    const dbAddress = OrbitDBAddress.parse(address);\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory); // Check if we have the database\n\n    const haveDB = await this._haveLocalData(options.cache, dbAddress);\n    logger.debug((haveDB ? 'Found' : 'Didn\\'t find') + ` database '${dbAddress}'`); // If we want to try and open the database local-only, throw an error\n    // if we don't have the database locally\n\n    if (options.localOnly && !haveDB) {\n      logger.warn(`Database '${dbAddress}' doesn't exist!`);\n      throw new Error(`Database '${dbAddress}' doesn't exist!`);\n    }\n\n    logger.debug(`Loading Manifest for '${dbAddress}'`); // Get the database manifest from IPFS\n\n    const manifest = await io.read(this._ipfs, dbAddress.root);\n    logger.debug(`Manifest for '${dbAddress}':\\n${JSON.stringify(manifest, null, 2)}`); // Make sure the type from the manifest matches the type that was given as an option\n\n    if (manifest.name !== dbAddress.path) {\n      throw new Error(`Manifest '${manifest.name}' cannot be opened as '${dbAddress.path}'`);\n    }\n\n    if (options.type && manifest.type !== options.type) {\n      throw new Error(`Database '${dbAddress}' is type '${manifest.type}' but was opened as '${options.type}'`);\n    } // Save the database locally\n\n\n    await this._addManifestToCache(options.cache, dbAddress); // Open the the database\n\n    options = Object.assign({}, options, {\n      accessControllerAddress: manifest.accessController,\n      meta: manifest.meta\n    });\n    return this._createStore(manifest.type, dbAddress, options);\n  } // Save the database locally\n\n\n  async _addManifestToCache(cache, dbAddress) {\n    await cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root);\n    logger.debug(`Saved manifest to IPFS as '${dbAddress.root}'`);\n  }\n  /**\n   * Check if we have the database, or part of it, saved locally\n   * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]\n   * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]\n   * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]\n   */\n\n\n  async _haveLocalData(cache, dbAddress) {\n    if (!cache) {\n      return false;\n    }\n\n    const addr = dbAddress.toString();\n    const data = await cache.get(path.join(addr, '_manifest'));\n    return data !== undefined && data !== null;\n  }\n  /**\n   * Runs all migrations inside the src/migration folder\n   * @param Object options  Options to pass into the migration\n   * @param OrbitDBAddress dbAddress Address of database in OrbitDBAddress format\n   */\n\n\n  async _migrate(options, dbAddress) {\n    await migrations.run(this, options, dbAddress);\n  }\n  /**\n   * Returns supported database types as an Array of strings\n   * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']\n   * @return {[Array]} [Supported database types]\n   */\n\n\n  static get databaseTypes() {\n    return Object.keys(databaseTypes);\n  }\n\n  static isValidType(type) {\n    return Object.keys(databaseTypes).includes(type);\n  }\n\n  static addDatabaseType(type, store) {\n    if (databaseTypes[type]) throw new Error(`Type already exists: ${type}`);\n    databaseTypes[type] = store;\n  }\n\n  static getDatabaseTypes() {\n    return databaseTypes;\n  }\n\n  static isValidAddress(address) {\n    return OrbitDBAddress.isValid(address);\n  }\n\n  static parseAddress(address) {\n    return OrbitDBAddress.parse(address);\n  }\n\n}\n\nmodule.exports = OrbitDB;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/orbit-db/src/OrbitDB.js"],"names":["path","require","EventStore","FeedStore","KeyValueStore","CounterStore","DocumentStore","Pubsub","Cache","Keystore","Identities","AccessControllers","OrbitDBAddress","createDBManifest","exchangeHeads","isDefined","io","Storage","migrations","Logger","logger","create","setLogLevel","databaseTypes","counter","eventlog","feed","docstore","keyvalue","OrbitDB","constructor","ipfs","identity","options","Error","_ipfs","id","peerId","_pubsub","offline","broker","directory","storage","_directConnections","caches","cache","handlers","Set","keystore","stores","createInstance","undefined","storageOptions","provider","keystorePath","join","keyStorage","createStore","createIdentity","cachePath","cacheStorage","finalOptions","Object","assign","address","type","open","log","kvstore","docs","disconnect","close","databases","values","db","toString","keys","removeDirectConnect","e","forEach","stop","_createCache","_createStore","Store","accessController","accessControllerAddress","resolve","opts","replicate","onClose","_onClose","bind","onDrop","_onDrop","onLoad","_onLoad","store","events","on","_onWrite","addr","subscribe","_onMessage","_onPeerConnected","entry","heads","publish","debug","length","JSON","stringify","map","hash","sync","error","peer","getStore","getDirectConnection","onChannelCreated","channel","_receiverID","onMessage","emit","unsubscribe","dir","has","delete","size","_requestCache","_cache","_determineAddress","name","isValidType","isValid","manifestHash","parse","dbAddress","haveDB","_haveLocalData","overwrite","_migrate","_addManifestToCache","determineAddress","onlyHash","existingCache","newCache","add","localOnly","warn","manifest","read","root","meta","set","data","get","run","includes","addDatabaseType","getDatabaseTypes","isValidAddress","parseAddress","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst path = require('path')\nconst EventStore = require('orbit-db-eventstore')\nconst FeedStore = require('orbit-db-feedstore')\nconst KeyValueStore = require('orbit-db-kvstore')\nconst CounterStore = require('orbit-db-counterstore')\nconst DocumentStore = require('orbit-db-docstore')\nconst Pubsub = require('orbit-db-pubsub')\nconst Cache = require('orbit-db-cache')\nconst Keystore = require('orbit-db-keystore')\nconst Identities = require('orbit-db-identity-provider')\nlet AccessControllers = require('orbit-db-access-controllers')\nconst OrbitDBAddress = require('./orbit-db-address')\nconst createDBManifest = require('./db-manifest')\nconst exchangeHeads = require('./exchange-heads')\nconst { isDefined, io } = require('./utils')\nconst Storage = require('orbit-db-storage-adapter')\nconst migrations = require('./migrations')\n\nconst Logger = require('logplease')\nconst logger = Logger.create('orbit-db')\nLogger.setLogLevel('ERROR')\n\n// Mapping for 'database type' -> Class\nconst databaseTypes = {\n  counter: CounterStore,\n  eventlog: EventStore,\n  feed: FeedStore,\n  docstore: DocumentStore,\n  keyvalue: KeyValueStore\n}\n\nclass OrbitDB {\n  constructor (ipfs, identity, options = {}) {\n    if (!isDefined(ipfs)) { throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance') }\n\n    if (!isDefined(identity)) { throw new Error('identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance') }\n\n    this._ipfs = ipfs\n    this.identity = identity\n    this.id = options.peerId\n    this._pubsub = !options.offline\n      ? options.broker\n        ? new options.broker(this._ipfs) // eslint-disable-line\n        : new Pubsub(this._ipfs, this.id)\n      : null\n    this.directory = options.directory || './orbitdb'\n    this.storage = options.storage\n    this._directConnections = {}\n\n    this.caches = {}\n    this.caches[this.directory] = { cache: options.cache, handlers: new Set() }\n    this.keystore = options.keystore\n    this.stores = {}\n\n    // AccessControllers module can be passed in to enable\n    // testing with orbit-db-access-controller\n    AccessControllers = options.AccessControllers || AccessControllers\n  }\n\n  static get Pubsub () { return Pubsub }\n  static get Cache () { return Cache }\n  static get Keystore () { return Keystore }\n  static get Identities () { return Identities }\n  static get AccessControllers () { return AccessControllers }\n  static get Storage () { return Storage }\n  static get OrbitDBAddress () { return OrbitDBAddress }\n\n  static get EventStore () { return EventStore }\n  static get FeedStore () { return FeedStore }\n  static get KeyValueStore () { return KeyValueStore }\n  static get CounterStore () { return CounterStore }\n  static get DocumentStore () { return DocumentStore }\n\n  get cache () { return this.caches[this.directory].cache }\n\n  static async createInstance (ipfs, options = {}) {\n    if (!isDefined(ipfs)) { throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance') }\n\n    if (options.offline === undefined) {\n      options.offline = false\n    }\n\n    if (options.offline && !options.id ) {\n      throw new Error('Offline mode requires passing an `id` in the options')\n    }\n\n    const { id } = options.offline ? ({ id: options.id }) : await ipfs.id()\n\n    if (!options.directory) { options.directory = './orbitdb' }\n\n    if (!options.storage) {\n      const storageOptions = {}\n\n      // Create default `level` store\n      options.storage = Storage(null, storageOptions)\n    }\n\n    if (options.identity && options.identity.provider.keystore) {\n      options.keystore = options.identity.provider.keystore\n    }\n\n    if (!options.keystore) {\n      const keystorePath = path.join(options.directory, id, '/keystore')\n      const keyStorage = await options.storage.createStore(keystorePath)\n      options.keystore = new Keystore(keyStorage)\n    }\n\n    if (!options.identity) {\n      options.identity = await Identities.createIdentity({\n        id: options.id || id,\n        keystore: options.keystore\n      })\n    }\n\n    if (!options.cache) {\n      const cachePath = path.join(options.directory, id, '/cache')\n      const cacheStorage = await options.storage.createStore(cachePath)\n      options.cache = new Cache(cacheStorage)\n    }\n\n    const finalOptions = Object.assign({}, options, { peerId: id })\n    return new OrbitDB(ipfs, options.identity, finalOptions)\n  }\n\n  /* Databases */\n  async feed (address, options = {}) {\n    options = Object.assign({ create: true, type: 'feed' }, options)\n    return this.open(address, options)\n  }\n\n  async log (address, options = {}) {\n    options = Object.assign({ create: true, type: 'eventlog' }, options)\n    return this.open(address, options)\n  }\n\n  async eventlog (address, options = {}) {\n    return this.log(address, options)\n  }\n\n  async keyvalue (address, options = {}) {\n    options = Object.assign({ create: true, type: 'keyvalue' }, options)\n    return this.open(address, options)\n  }\n\n  async kvstore (address, options = {}) {\n    return this.keyvalue(address, options)\n  }\n\n  async counter (address, options = {}) {\n    options = Object.assign({ create: true, type: 'counter' }, options)\n    return this.open(address, options)\n  }\n\n  async docs (address, options = {}) {\n    options = Object.assign({ create: true, type: 'docstore' }, options)\n    return this.open(address, options)\n  }\n\n  async docstore (address, options = {}) {\n    return this.docs(address, options)\n  }\n\n  async disconnect () {\n    // close keystore\n    await this.keystore.close()\n\n    // Close all open databases\n    const databases = Object.values(this.stores)\n    for (const db of databases) {\n      await db.close()\n      delete this.stores[db.address.toString()]\n    }\n\n    const caches = Object.keys(this.caches)\n    for (const directory of caches) {\n      await this.caches[directory].cache.close()\n      delete this.caches[directory]\n    }\n\n    // Close a direct connection and remove it from internal state\n    const removeDirectConnect = e => {\n      this._directConnections[e].close()\n      delete this._directConnections[e]\n    }\n\n    // Close all direct connections to peers\n    Object.keys(this._directConnections).forEach(removeDirectConnect)\n\n    // Disconnect from pubsub\n    if (this._pubsub) {\n      await this._pubsub.disconnect()\n    }\n\n    // Remove all databases from the state\n    this.stores = {}\n  }\n\n  // Alias for disconnect()\n  async stop () {\n    await this.disconnect()\n  }\n\n  async _createCache (path) {\n    const cacheStorage = await this.storage.createStore(path)\n    return new Cache(cacheStorage)\n  }\n\n  /* Private methods */\n  async _createStore (type, address, options) {\n    // Get the type -> class mapping\n    const Store = databaseTypes[type]\n\n    if (!Store) { throw new Error(`Invalid database type '${type}'`) }\n\n    let accessController\n    if (options.accessControllerAddress) {\n      accessController = await AccessControllers.resolve(this, options.accessControllerAddress, options.accessController)\n    }\n\n    const opts = Object.assign({ replicate: true }, options, {\n      accessController: accessController,\n      cache: options.cache,\n      onClose: this._onClose.bind(this),\n      onDrop: this._onDrop.bind(this),\n      onLoad: this._onLoad.bind(this)\n    })\n    const identity = options.identity || this.identity\n\n    const store = new Store(this._ipfs, identity, address, opts)\n    store.events.on('write', this._onWrite.bind(this))\n\n    // ID of the store is the address as a string\n    const addr = address.toString()\n    this.stores[addr] = store\n\n    // Subscribe to pubsub to get updates from peers,\n    // this is what hooks us into the message propagation layer\n    // and the p2p network\n    if (opts.replicate && this._pubsub) { await this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this)) }\n\n    return store\n  }\n\n  // Callback for local writes to the database. We the update to pubsub.\n  _onWrite (address, entry, heads) {\n    if (!heads) throw new Error(\"'heads' not defined\")\n    if (this._pubsub) this._pubsub.publish(address, heads)\n  }\n\n  // Callback for receiving a message from the network\n  async _onMessage (address, heads) {\n    const store = this.stores[address]\n    try {\n      logger.debug(`Received ${heads.length} heads for '${address}':\\n`, JSON.stringify(heads.map(e => e.hash), null, 2))\n      if (store && heads && heads.length > 0) {\n        await store.sync(heads)\n      }\n    } catch (e) {\n      logger.error(e)\n    }\n  }\n\n  // Callback for when a peer connected to a database\n  async _onPeerConnected (address, peer) {\n    logger.debug(`New peer '${peer}' connected to '${address}'`)\n\n    const getStore = address => this.stores[address]\n    const getDirectConnection = peer => this._directConnections[peer]\n    const onChannelCreated = channel => { this._directConnections[channel._receiverID] = channel }\n\n    const onMessage = (address, heads) => this._onMessage(address, heads)\n\n    await exchangeHeads(\n      this._ipfs,\n      address,\n      peer,\n      getStore,\n      getDirectConnection,\n      onMessage,\n      onChannelCreated\n    )\n\n    if (getStore(address)) { getStore(address).events.emit('peer', peer) }\n  }\n\n  // Callback when database was closed\n  async _onClose (db) {\n    const address = db.address.toString()\n    logger.debug(`Close ${address}`)\n\n    // Unsubscribe from pubsub\n    if (this._pubsub) {\n      await this._pubsub.unsubscribe(address)\n    }\n\n    const store = this.stores[address]\n    const dir = store && store.options.directory ? store.options.directory : this.directory\n    const cache = this.caches[dir]\n\n    if (cache && cache.handlers.has(address)) {\n      cache.handlers.delete(address)\n      if (!cache.handlers.size) await cache.cache.close()\n    }\n\n    delete this.stores[address]\n  }\n\n  async _onDrop (db) {\n    const address = db.address.toString()\n    const dir = db && db.options.directory ? db.options.directory : this.directory\n    await this._requestCache(address, dir, db._cache)\n    this.stores[address] = db\n  }\n\n  async _onLoad (db) {\n    const address = db.address.toString()\n    const dir = db && db.options.directory ? db.options.directory : this.directory\n    await this._requestCache(address, dir, db._cache)\n    this.stores[address] = db\n  }\n\n  async _determineAddress (name, type, options = {}) {\n    if (!OrbitDB.isValidType(type)) { throw new Error(`Invalid database type '${type}'`) }\n\n    if (OrbitDBAddress.isValid(name)) { throw new Error('Given database name is an address. Please give only the name of the database!') }\n\n    // Create an AccessController, use IPFS AC as the default\n    options.accessController = Object.assign({}, { name: name, type: 'ipfs' }, options.accessController)\n    const accessControllerAddress = await AccessControllers.create(this, options.accessController.type, options.accessController || {})\n\n    // Save the manifest to IPFS\n    const manifestHash = await createDBManifest(this._ipfs, name, type, accessControllerAddress, options)\n\n    // Create the database address\n    return OrbitDBAddress.parse(OrbitDBAddress.join(manifestHash, name))\n  }\n\n  /* Create and Open databases */\n\n  /*\n    options = {\n      accessController: { write: [] } // array of keys that can write to this database\n      overwrite: false, // whether we should overwrite the existing database if it exists\n    }\n  */\n  async create (name, type, options = {}) {\n    logger.debug('create()')\n\n    logger.debug(`Creating database '${name}' as ${type}`)\n\n    // Create the database address\n    const dbAddress = await this._determineAddress(name, type, options)\n\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory)\n\n    // Check if we have the database locally\n    const haveDB = await this._haveLocalData(options.cache, dbAddress)\n\n    if (haveDB && !options.overwrite) { throw new Error(`Database '${dbAddress}' already exists!`) }\n\n    await this._migrate(options, dbAddress)\n\n    // Save the database locally\n    await this._addManifestToCache(options.cache, dbAddress)\n\n    logger.debug(`Created database '${dbAddress}'`)\n\n    // Open the database\n    return this.open(dbAddress, options)\n  }\n\n  async determineAddress (name, type, options = {}) {\n    const opts = Object.assign({}, { onlyHash: true }, options)\n    return this._determineAddress(name, type, opts)\n  }\n\n  async _requestCache (address, directory, existingCache) {\n    const dir = directory || this.directory\n    if (!this.caches[dir]) {\n      const newCache = existingCache || await this._createCache(dir)\n      this.caches[dir] = { cache: newCache, handlers: new Set() }\n    }\n    this.caches[dir].handlers.add(address)\n    const cache = this.caches[dir].cache\n\n    // \"Wake up\" the caches if they need it\n    if (cache) await cache.open()\n\n    return cache\n  }\n\n  /*\n      options = {\n        localOnly: false // if set to true, throws an error if database can't be found locally\n        create: false // whether to create the database\n        type: TODO\n        overwrite: TODO\n\n      }\n   */\n  async open (address, options = {}) {\n    logger.debug('open()')\n\n    options = Object.assign({ localOnly: false, create: false }, options)\n    logger.debug(`Open database '${address}'`)\n\n    // If address is just the name of database, check the options to crate the database\n    if (!OrbitDBAddress.isValid(address)) {\n      if (!options.create) {\n        throw new Error('\\'options.create\\' set to \\'false\\'. If you want to create a database, set \\'options.create\\' to \\'true\\'.')\n      } else if (options.create && !options.type) {\n        throw new Error(`Database type not provided! Provide a type with 'options.type' (${OrbitDB.databaseTypes.join('|')})`)\n      } else {\n        logger.warn(`Not a valid OrbitDB address '${address}', creating the database`)\n        options.overwrite = options.overwrite ? options.overwrite : true\n        return this.create(address, options.type, options)\n      }\n    }\n\n    // Parse the database address\n    const dbAddress = OrbitDBAddress.parse(address)\n\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory)\n\n    // Check if we have the database\n    const haveDB = await this._haveLocalData(options.cache, dbAddress)\n\n    logger.debug((haveDB ? 'Found' : 'Didn\\'t find') + ` database '${dbAddress}'`)\n\n    // If we want to try and open the database local-only, throw an error\n    // if we don't have the database locally\n    if (options.localOnly && !haveDB) {\n      logger.warn(`Database '${dbAddress}' doesn't exist!`)\n      throw new Error(`Database '${dbAddress}' doesn't exist!`)\n    }\n\n    logger.debug(`Loading Manifest for '${dbAddress}'`)\n\n    // Get the database manifest from IPFS\n    const manifest = await io.read(this._ipfs, dbAddress.root)\n    logger.debug(`Manifest for '${dbAddress}':\\n${JSON.stringify(manifest, null, 2)}`)\n\n    // Make sure the type from the manifest matches the type that was given as an option\n    if (manifest.name !== dbAddress.path) { throw new Error(`Manifest '${manifest.name}' cannot be opened as '${dbAddress.path}'`) }\n    if (options.type && manifest.type !== options.type) { throw new Error(`Database '${dbAddress}' is type '${manifest.type}' but was opened as '${options.type}'`) }\n\n    // Save the database locally\n    await this._addManifestToCache(options.cache, dbAddress)\n\n    // Open the the database\n    options = Object.assign({}, options, { accessControllerAddress: manifest.accessController, meta: manifest.meta })\n    return this._createStore(manifest.type, dbAddress, options)\n  }\n\n  // Save the database locally\n  async _addManifestToCache (cache, dbAddress) {\n    await cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root)\n    logger.debug(`Saved manifest to IPFS as '${dbAddress.root}'`)\n  }\n\n  /**\n   * Check if we have the database, or part of it, saved locally\n   * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]\n   * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]\n   * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]\n   */\n  async _haveLocalData (cache, dbAddress) {\n    if (!cache) {\n      return false\n    }\n\n    const addr = dbAddress.toString()\n    const data = await cache.get(path.join(addr, '_manifest'))\n    return data !== undefined && data !== null\n  }\n\n  /**\n   * Runs all migrations inside the src/migration folder\n   * @param Object options  Options to pass into the migration\n   * @param OrbitDBAddress dbAddress Address of database in OrbitDBAddress format\n   */\n  async _migrate (options, dbAddress) {\n    await migrations.run(this, options, dbAddress)\n  }\n\n  /**\n   * Returns supported database types as an Array of strings\n   * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']\n   * @return {[Array]} [Supported database types]\n   */\n  static get databaseTypes () {\n    return Object.keys(databaseTypes)\n  }\n\n  static isValidType (type) {\n    return Object.keys(databaseTypes).includes(type)\n  }\n\n  static addDatabaseType (type, store) {\n    if (databaseTypes[type]) throw new Error(`Type already exists: ${type}`)\n    databaseTypes[type] = store\n  }\n\n  static getDatabaseTypes () {\n    return databaseTypes\n  }\n\n  static isValidAddress (address) {\n    return OrbitDBAddress.isValid(address)\n  }\n\n  static parseAddress (address) {\n    return OrbitDBAddress.parse(address)\n  }\n}\n\nmodule.exports = OrbitDB\n"]},"metadata":{},"sourceType":"script"}