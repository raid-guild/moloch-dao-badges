{"ast":null,"code":"'use strict';\n\nconst {\n  Key,\n  Errors,\n  utils\n} = require('interface-datastore');\n\nconst {\n  filter,\n  map,\n  take,\n  sortAll\n} = utils;\n/**\n * A datastore backed by leveldb.\n */\n\nclass LevelDatastore {\n  constructor(path, opts) {\n    let database;\n\n    if (opts && opts.db) {\n      database = opts.db;\n      delete opts.db;\n    } else {\n      database = require('level');\n    }\n\n    this.db = this._initDb(database, path, opts);\n  }\n\n  _initDb(database, path, opts) {\n    return database(path, { ...opts,\n      valueEncoding: 'binary',\n      compression: false // same default as go\n\n    });\n  }\n\n  async open() {\n    try {\n      await this.db.open();\n    } catch (err) {\n      throw Errors.dbOpenFailedError(err);\n    }\n  }\n\n  async put(key, value) {\n    try {\n      await this.db.put(key.toString(), value);\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err);\n    }\n  }\n\n  async get(key) {\n    let data;\n\n    try {\n      data = await this.db.get(key.toString());\n    } catch (err) {\n      if (err.notFound) throw Errors.notFoundError(err);\n      throw Errors.dbWriteFailedError(err);\n    }\n\n    return data;\n  }\n\n  async has(key) {\n    try {\n      await this.db.get(key.toString());\n    } catch (err) {\n      if (err.notFound) return false;\n      throw err;\n    }\n\n    return true;\n  }\n\n  async delete(key) {\n    try {\n      await this.db.del(key.toString());\n    } catch (err) {\n      throw Errors.dbDeleteFailedError(err);\n    }\n  }\n\n  close() {\n    return this.db.close();\n  }\n\n  batch() {\n    const ops = [];\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        });\n      },\n      delete: key => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        });\n      },\n      commit: () => {\n        return this.db.batch(ops);\n      }\n    };\n  }\n\n  query(q) {\n    let values = true;\n\n    if (q.keysOnly != null) {\n      values = !q.keysOnly;\n    }\n\n    const opts = {\n      keys: true,\n      values: values,\n      keyAsBuffer: true\n    }; // Let the db do the prefix matching\n\n    if (q.prefix != null) {\n      const prefix = q.prefix.toString(); // Match keys greater than or equal to `prefix` and\n\n      opts.gte = prefix; // less than `prefix` + \\xFF (hex escape sequence)\n\n      opts.lt = prefix + '\\xFF';\n    }\n\n    let it = levelIteratorToIterator(this.db.iterator(opts));\n    it = map(it, ({\n      key,\n      value\n    }) => {\n      const res = {\n        key: new Key(key, false)\n      };\n\n      if (values) {\n        res.value = Buffer.from(value);\n      }\n\n      return res;\n    });\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n\n    return it;\n  }\n\n}\n\nfunction levelIteratorToIterator(li) {\n  return {\n    next: () => new Promise((resolve, reject) => {\n      li.next((err, key, value) => {\n        if (err) return reject(err);\n\n        if (key == null) {\n          return li.end(err => {\n            if (err) return reject(err);\n            resolve({\n              done: true\n            });\n          });\n        }\n\n        resolve({\n          done: false,\n          value: {\n            key,\n            value\n          }\n        });\n      });\n    }),\n    return: () => new Promise((resolve, reject) => {\n      li.end(err => {\n        if (err) return reject(err);\n        resolve({\n          done: true\n        });\n      });\n    }),\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nmodule.exports = LevelDatastore;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/datastore-level/src/index.js"],"names":["Key","Errors","utils","require","filter","map","take","sortAll","LevelDatastore","constructor","path","opts","database","db","_initDb","valueEncoding","compression","open","err","dbOpenFailedError","put","key","value","toString","dbWriteFailedError","get","data","notFound","notFoundError","has","delete","del","dbDeleteFailedError","close","batch","ops","push","type","commit","query","q","values","keysOnly","keys","keyAsBuffer","prefix","gte","lt","it","levelIteratorToIterator","iterator","res","Buffer","from","Array","isArray","filters","reduce","f","orders","offset","i","limit","li","next","Promise","resolve","reject","end","done","return","Symbol","asyncIterator","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Key, Errors, utils } = require('interface-datastore')\nconst { filter, map, take, sortAll } = utils\n\n/**\n * A datastore backed by leveldb.\n */\nclass LevelDatastore {\n  constructor (path, opts) {\n    let database\n\n    if (opts && opts.db) {\n      database = opts.db\n      delete opts.db\n    } else {\n      database = require('level')\n    }\n\n    this.db = this._initDb(database, path, opts)\n  }\n\n  _initDb (database, path, opts) {\n    return database(path, {\n      ...opts,\n      valueEncoding: 'binary',\n      compression: false // same default as go\n    })\n  }\n\n  async open () {\n    try {\n      await this.db.open()\n    } catch (err) {\n      throw Errors.dbOpenFailedError(err)\n    }\n  }\n\n  async put (key, value) {\n    try {\n      await this.db.put(key.toString(), value)\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err)\n    }\n  }\n\n  async get (key) {\n    let data\n    try {\n      data = await this.db.get(key.toString())\n    } catch (err) {\n      if (err.notFound) throw Errors.notFoundError(err)\n      throw Errors.dbWriteFailedError(err)\n    }\n    return data\n  }\n\n  async has (key) {\n    try {\n      await this.db.get(key.toString())\n    } catch (err) {\n      if (err.notFound) return false\n      throw err\n    }\n    return true\n  }\n\n  async delete (key) {\n    try {\n      await this.db.del(key.toString())\n    } catch (err) {\n      throw Errors.dbDeleteFailedError(err)\n    }\n  }\n\n  close () {\n    return this.db.close()\n  }\n\n  batch () {\n    const ops = []\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        })\n      },\n      delete: (key) => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        })\n      },\n      commit: () => {\n        return this.db.batch(ops)\n      }\n    }\n  }\n\n  query (q) {\n    let values = true\n    if (q.keysOnly != null) {\n      values = !q.keysOnly\n    }\n\n    const opts = {\n      keys: true,\n      values: values,\n      keyAsBuffer: true\n    }\n\n    // Let the db do the prefix matching\n    if (q.prefix != null) {\n      const prefix = q.prefix.toString()\n      // Match keys greater than or equal to `prefix` and\n      opts.gte = prefix\n      // less than `prefix` + \\xFF (hex escape sequence)\n      opts.lt = prefix + '\\xFF'\n    }\n\n    let it = levelIteratorToIterator(\n      this.db.iterator(opts)\n    )\n\n    it = map(it, ({ key, value }) => {\n      const res = { key: new Key(key, false) }\n      if (values) {\n        res.value = Buffer.from(value)\n      }\n      return res\n    })\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it)\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= q.offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n}\n\nfunction levelIteratorToIterator (li) {\n  return {\n    next: () => new Promise((resolve, reject) => {\n      li.next((err, key, value) => {\n        if (err) return reject(err)\n        if (key == null) {\n          return li.end(err => {\n            if (err) return reject(err)\n            resolve({ done: true })\n          })\n        }\n        resolve({ done: false, value: { key, value } })\n      })\n    }),\n    return: () => new Promise((resolve, reject) => {\n      li.end(err => {\n        if (err) return reject(err)\n        resolve({ done: true })\n      })\n    }),\n    [Symbol.asyncIterator] () {\n      return this\n    }\n  }\n}\n\nmodule.exports = LevelDatastore\n"]},"metadata":{},"sourceType":"script"}