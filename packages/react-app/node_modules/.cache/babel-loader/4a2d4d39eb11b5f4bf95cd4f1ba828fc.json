{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst ip = require('./ip');\n\nconst protocols = require('./protocols-table');\n\nconst CID = require('cids');\n\nconst multibase = require('multibase');\n\nconst varint = require('varint');\n\nmodule.exports = Convert; // converts (serializes) addresses\n\nfunction Convert(proto, a) {\n  if (a instanceof Buffer) {\n    return Convert.toString(proto, a);\n  } else {\n    return Convert.toBuffer(proto, a);\n  }\n}\n\nConvert.toString = function convertToString(proto, buf) {\n  proto = protocols(proto);\n\n  switch (proto.code) {\n    case 4: // ipv4\n\n    case 41:\n      // ipv6\n      return buf2ip(buf);\n\n    case 6: // tcp\n\n    case 273: // udp\n\n    case 33: // dccp\n\n    case 132:\n      // sctp\n      return buf2port(buf);\n\n    case 53: // dns\n\n    case 54: // dns4\n\n    case 55: // dns6\n\n    case 56: // dnsaddr\n\n    case 400:\n      // unix\n      return buf2str(buf);\n\n    case 421:\n      // ipfs\n      return buf2mh(buf);\n\n    case 444:\n      // onion\n      return buf2onion(buf);\n\n    case 445:\n      // onion3\n      return buf2onion(buf);\n\n    default:\n      return buf.toString('hex');\n    // no clue. convert to hex\n  }\n};\n\nConvert.toBuffer = function convertToBuffer(proto, str) {\n  proto = protocols(proto);\n\n  switch (proto.code) {\n    case 4:\n      // ipv4\n      return ip2buf(str);\n\n    case 41:\n      // ipv6\n      return ip2buf(str);\n\n    case 6: // tcp\n\n    case 273: // udp\n\n    case 33: // dccp\n\n    case 132:\n      // sctp\n      return port2buf(parseInt(str, 10));\n\n    case 53: // dns\n\n    case 54: // dns4\n\n    case 55: // dns6\n\n    case 56: // dnsaddr\n\n    case 400:\n      // unix\n      return str2buf(str);\n\n    case 421:\n      // ipfs\n      return mh2buf(str);\n\n    case 444:\n      // onion\n      return onion2buf(str);\n\n    case 445:\n      // onion3\n      return onion32buf(str);\n\n    default:\n      return Buffer.from(str, 'hex');\n    // no clue. convert from hex\n  }\n};\n\nfunction ip2buf(ipString) {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n\n  return ip.toBuffer(ipString);\n}\n\nfunction buf2ip(ipBuff) {\n  const ipString = ip.toString(ipBuff);\n\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n\n  return ipString;\n}\n\nfunction port2buf(port) {\n  const buf = Buffer.alloc(2);\n  buf.writeUInt16BE(port, 0);\n  return buf;\n}\n\nfunction buf2port(buf) {\n  return buf.readUInt16BE(0);\n}\n\nfunction str2buf(str) {\n  const buf = Buffer.from(str);\n  const size = Buffer.from(varint.encode(buf.length));\n  return Buffer.concat([size, buf]);\n}\n\nfunction buf2str(buf) {\n  const size = varint.decode(buf);\n  buf = buf.slice(varint.decode.bytes);\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return buf.toString();\n}\n\nfunction mh2buf(hash) {\n  // the address is a varint prefixed multihash string representation\n  const mh = new CID(hash).multihash;\n  const size = Buffer.from(varint.encode(mh.length));\n  return Buffer.concat([size, mh]);\n}\n\nfunction buf2mh(buf) {\n  const size = varint.decode(buf);\n  const address = buf.slice(varint.decode.bytes);\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return multibase.encode('base58btc', address).toString().slice(1);\n}\n\nfunction onion2buf(str) {\n  const addr = str.split(':');\n\n  if (addr.length !== 2) {\n    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number');\n  }\n\n  if (addr[0].length !== 16) {\n    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion address.');\n  } // onion addresses do not include the multibase prefix, add it before decoding\n\n\n  const buf = multibase.decode('b' + addr[0]); // onion port number\n\n  const port = parseInt(addr[1], 10);\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n\n  const portBuf = port2buf(port);\n  return Buffer.concat([buf, portBuf]);\n}\n\nfunction onion32buf(str) {\n  const addr = str.split(':');\n\n  if (addr.length !== 2) {\n    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number');\n  }\n\n  if (addr[0].length !== 56) {\n    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion3 address.');\n  } // onion addresses do not include the multibase prefix, add it before decoding\n\n\n  const buf = multibase.decode('b' + addr[0]); // onion port number\n\n  const port = parseInt(addr[1], 10);\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n\n  const portBuf = port2buf(port);\n  return Buffer.concat([buf, portBuf]);\n}\n\nfunction buf2onion(buf) {\n  const addrBytes = buf.slice(0, buf.length - 2);\n  const portBytes = buf.slice(buf.length - 2);\n  const addr = multibase.encode('base32', addrBytes).toString().slice(1);\n  const port = buf2port(portBytes);\n  return addr + ':' + port;\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/is-ipfs/node_modules/multiaddr/src/convert.js"],"names":["Buffer","require","ip","protocols","CID","multibase","varint","module","exports","Convert","proto","a","toString","toBuffer","convertToString","buf","code","buf2ip","buf2port","buf2str","buf2mh","buf2onion","convertToBuffer","str","ip2buf","port2buf","parseInt","str2buf","mh2buf","onion2buf","onion32buf","from","ipString","isIP","Error","ipBuff","port","alloc","writeUInt16BE","readUInt16BE","size","encode","length","concat","decode","slice","bytes","hash","mh","multihash","address","addr","split","portBuf","addrBytes","portBytes"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst ip = require('./ip')\nconst protocols = require('./protocols-table')\nconst CID = require('cids')\nconst multibase = require('multibase')\nconst varint = require('varint')\n\nmodule.exports = Convert\n\n// converts (serializes) addresses\nfunction Convert (proto, a) {\n  if (a instanceof Buffer) {\n    return Convert.toString(proto, a)\n  } else {\n    return Convert.toBuffer(proto, a)\n  }\n}\n\nConvert.toString = function convertToString (proto, buf) {\n  proto = protocols(proto)\n  switch (proto.code) {\n    case 4: // ipv4\n    case 41: // ipv6\n      return buf2ip(buf)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return buf2port(buf)\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n      return buf2str(buf)\n\n    case 421: // ipfs\n      return buf2mh(buf)\n    case 444: // onion\n      return buf2onion(buf)\n    case 445: // onion3\n      return buf2onion(buf)\n    default:\n      return buf.toString('hex') // no clue. convert to hex\n  }\n}\n\nConvert.toBuffer = function convertToBuffer (proto, str) {\n  proto = protocols(proto)\n  switch (proto.code) {\n    case 4: // ipv4\n      return ip2buf(str)\n    case 41: // ipv6\n      return ip2buf(str)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return port2buf(parseInt(str, 10))\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n      return str2buf(str)\n\n    case 421: // ipfs\n      return mh2buf(str)\n    case 444: // onion\n      return onion2buf(str)\n    case 445: // onion3\n      return onion32buf(str)\n    default:\n      return Buffer.from(str, 'hex') // no clue. convert from hex\n  }\n}\n\nfunction ip2buf (ipString) {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ip.toBuffer(ipString)\n}\n\nfunction buf2ip (ipBuff) {\n  const ipString = ip.toString(ipBuff)\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ipString\n}\n\nfunction port2buf (port) {\n  const buf = Buffer.alloc(2)\n  buf.writeUInt16BE(port, 0)\n  return buf\n}\n\nfunction buf2port (buf) {\n  return buf.readUInt16BE(0)\n}\n\nfunction str2buf (str) {\n  const buf = Buffer.from(str)\n  const size = Buffer.from(varint.encode(buf.length))\n  return Buffer.concat([size, buf])\n}\n\nfunction buf2str (buf) {\n  const size = varint.decode(buf)\n  buf = buf.slice(varint.decode.bytes)\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return buf.toString()\n}\n\nfunction mh2buf (hash) {\n  // the address is a varint prefixed multihash string representation\n  const mh = new CID(hash).multihash\n  const size = Buffer.from(varint.encode(mh.length))\n  return Buffer.concat([size, mh])\n}\n\nfunction buf2mh (buf) {\n  const size = varint.decode(buf)\n  const address = buf.slice(varint.decode.bytes)\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n  return multibase.encode('base58btc', address).toString().slice(1)\n}\n\nfunction onion2buf (str) {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number')\n  }\n  if (addr[0].length !== 16) {\n    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion address.')\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = multibase.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2buf(port)\n  return Buffer.concat([buf, portBuf])\n}\n\nfunction onion32buf (str) {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number')\n  }\n  if (addr[0].length !== 56) {\n    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion3 address.')\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = multibase.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2buf(port)\n  return Buffer.concat([buf, portBuf])\n}\n\nfunction buf2onion (buf) {\n  const addrBytes = buf.slice(0, buf.length - 2)\n  const portBytes = buf.slice(buf.length - 2)\n  const addr = multibase.encode('base32', addrBytes).toString().slice(1)\n  const port = buf2port(portBytes)\n  return addr + ':' + port\n}\n"]},"metadata":{},"sourceType":"script"}