{"ast":null,"code":"'use strict';\n\nrequire('node-forge/lib/x509');\n\nconst forge = require('node-forge/lib/forge');\n\nconst pki = forge.pki;\nexports = module.exports;\n/**\n * Gets a self-signed X.509 certificate for the key.\n *\n * The output Buffer contains the PKCS #7 message in DER.\n *\n * TODO: move to libp2p-crypto package\n *\n * @param {KeyInfo} key - The id and name of the key\n * @param {RsaPrivateKey} privateKey - The naked key\n * @returns {undefined}\n */\n\nexports.certificateForKey = (key, privateKey) => {\n  const publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e);\n  const cert = pki.createCertificate();\n  cert.publicKey = publicKey;\n  cert.serialNumber = '01';\n  cert.validity.notBefore = new Date();\n  cert.validity.notAfter = new Date();\n  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);\n  const attrs = [{\n    name: 'organizationName',\n    value: 'ipfs'\n  }, {\n    shortName: 'OU',\n    value: 'keystore'\n  }, {\n    name: 'commonName',\n    value: key.id\n  }];\n  cert.setSubject(attrs);\n  cert.setIssuer(attrs);\n  cert.setExtensions([{\n    name: 'basicConstraints',\n    cA: true\n  }, {\n    name: 'keyUsage',\n    keyCertSign: true,\n    digitalSignature: true,\n    nonRepudiation: true,\n    keyEncipherment: true,\n    dataEncipherment: true\n  }, {\n    name: 'extKeyUsage',\n    serverAuth: true,\n    clientAuth: true,\n    codeSigning: true,\n    emailProtection: true,\n    timeStamping: true\n  }, {\n    name: 'nsCertType',\n    client: true,\n    server: true,\n    email: true,\n    objsign: true,\n    sslCA: true,\n    emailCA: true,\n    objCA: true\n  }]); // self-sign certificate\n\n  cert.sign(privateKey);\n  return cert;\n};\n/**\n * Finds the first item in a collection that is matched in the\n * `asyncCompare` function.\n *\n * `asyncCompare` is an async function that must\n * resolve to either `true` or `false`.\n *\n * @param {Array} array\n * @param {function(*)} asyncCompare An async function that returns a boolean\n */\n\n\nasync function findAsync(array, asyncCompare) {\n  const promises = array.map(asyncCompare);\n  const results = await Promise.all(promises);\n  const index = results.findIndex(result => result);\n  return array[index];\n}\n\nmodule.exports.findAsync = findAsync;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-keychain/src/util.js"],"names":["require","forge","pki","exports","module","certificateForKey","key","privateKey","publicKey","setRsaPublicKey","n","e","cert","createCertificate","serialNumber","validity","notBefore","Date","notAfter","setFullYear","getFullYear","attrs","name","value","shortName","id","setSubject","setIssuer","setExtensions","cA","keyCertSign","digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","serverAuth","clientAuth","codeSigning","emailProtection","timeStamping","client","server","email","objsign","sslCA","emailCA","objCA","sign","findAsync","array","asyncCompare","promises","map","results","Promise","all","index","findIndex","result"],"mappings":"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","sourcesContent":["'use strict'\n\nrequire('node-forge/lib/x509')\nconst forge = require('node-forge/lib/forge')\nconst pki = forge.pki\nexports = module.exports\n\n/**\n * Gets a self-signed X.509 certificate for the key.\n *\n * The output Buffer contains the PKCS #7 message in DER.\n *\n * TODO: move to libp2p-crypto package\n *\n * @param {KeyInfo} key - The id and name of the key\n * @param {RsaPrivateKey} privateKey - The naked key\n * @returns {undefined}\n */\nexports.certificateForKey = (key, privateKey) => {\n  const publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e)\n  const cert = pki.createCertificate()\n  cert.publicKey = publicKey\n  cert.serialNumber = '01'\n  cert.validity.notBefore = new Date()\n  cert.validity.notAfter = new Date()\n  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10)\n  const attrs = [{\n    name: 'organizationName',\n    value: 'ipfs'\n  }, {\n    shortName: 'OU',\n    value: 'keystore'\n  }, {\n    name: 'commonName',\n    value: key.id\n  }]\n  cert.setSubject(attrs)\n  cert.setIssuer(attrs)\n  cert.setExtensions([{\n    name: 'basicConstraints',\n    cA: true\n  }, {\n    name: 'keyUsage',\n    keyCertSign: true,\n    digitalSignature: true,\n    nonRepudiation: true,\n    keyEncipherment: true,\n    dataEncipherment: true\n  }, {\n    name: 'extKeyUsage',\n    serverAuth: true,\n    clientAuth: true,\n    codeSigning: true,\n    emailProtection: true,\n    timeStamping: true\n  }, {\n    name: 'nsCertType',\n    client: true,\n    server: true,\n    email: true,\n    objsign: true,\n    sslCA: true,\n    emailCA: true,\n    objCA: true\n  }])\n  // self-sign certificate\n  cert.sign(privateKey)\n\n  return cert\n}\n\n/**\n * Finds the first item in a collection that is matched in the\n * `asyncCompare` function.\n *\n * `asyncCompare` is an async function that must\n * resolve to either `true` or `false`.\n *\n * @param {Array} array\n * @param {function(*)} asyncCompare An async function that returns a boolean\n */\nasync function findAsync (array, asyncCompare) {\n  const promises = array.map(asyncCompare)\n  const results = await Promise.all(promises)\n  const index = results.findIndex(result => result)\n  return array[index]\n}\n\nmodule.exports.findAsync = findAsync\n"]},"metadata":{},"sourceType":"script"}