{"ast":null,"code":"'use strict';\n\nconst batch = require('async-iterator-batch');\n\nmodule.exports = function* trickleReduceToRoot(source, reduce, options) {\n  yield trickleStream(source, reduce, options);\n};\n\nasync function trickleStream(source, reduce, options) {\n  let root;\n  let iteration = 0;\n  let maxDepth = 1;\n  let subTree = root = new Root(options.layerRepeat);\n\n  for await (const layer of batch(source, options.maxChildrenPerNode)) {\n    if (subTree.isFull()) {\n      if (subTree !== root) {\n        root.addChild((await subTree.reduce(reduce)));\n      }\n\n      if (iteration && iteration % options.layerRepeat === 0) {\n        maxDepth++;\n      }\n\n      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);\n      iteration++;\n    }\n\n    subTree.append(layer);\n  }\n\n  if (subTree && subTree !== root) {\n    root.addChild((await subTree.reduce(reduce)));\n  }\n\n  return root.reduce(reduce);\n}\n\nclass SubTree {\n  constructor(maxDepth, layerRepeat, iteration) {\n    this.maxDepth = maxDepth;\n    this.layerRepeat = layerRepeat;\n    this.currentDepth = 1;\n    this.iteration = iteration;\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    };\n  }\n\n  isFull() {\n    if (!this.root.data) {\n      return false;\n    }\n\n    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n      // can descend\n      this._addNextNodeToParent(this.node);\n\n      return false;\n    } // try to find new node from node.parent\n\n\n    const distantRelative = this._findParent(this.node, this.currentDepth);\n\n    if (distantRelative) {\n      this._addNextNodeToParent(distantRelative);\n\n      return false;\n    }\n\n    return true;\n  }\n\n  _addNextNodeToParent(parent) {\n    this.parent = parent; // find site for new node\n\n    const nextNode = {\n      children: [],\n      depth: parent.depth + 1,\n      parent,\n      maxDepth: this.maxDepth,\n      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n    };\n    parent.children.push(nextNode);\n    this.currentDepth = nextNode.depth;\n    this.node = nextNode;\n  }\n\n  append(layer) {\n    this.node.data = layer;\n  }\n\n  reduce(reduce) {\n    return this._reduce(this.root, reduce);\n  }\n\n  async _reduce(node, reduce) {\n    let children = [];\n\n    if (node.children.length) {\n      children = await Promise.all(node.children.filter(child => child.data).map(child => this._reduce(child, reduce)));\n    }\n\n    return reduce(node.data.concat(children));\n  }\n\n  _findParent(node, depth) {\n    const parent = node.parent;\n\n    if (!parent || parent.depth === 0) {\n      return;\n    }\n\n    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n      // this layer is full, may be able to traverse to a different branch\n      return this._findParent(parent, depth);\n    }\n\n    return parent;\n  }\n\n}\n\nclass Root extends SubTree {\n  constructor(layerRepeat) {\n    super(0, layerRepeat);\n    this.root.depth = 0;\n    this.currentDepth = 1;\n  }\n\n  addChild(child) {\n    this.root.children.push(child);\n  }\n\n  reduce(reduce) {\n    return reduce(this.root.data.concat(this.root.children));\n  }\n\n}","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js"],"names":["batch","require","module","exports","trickleReduceToRoot","source","reduce","options","trickleStream","root","iteration","maxDepth","subTree","Root","layerRepeat","layer","maxChildrenPerNode","isFull","addChild","SubTree","append","constructor","currentDepth","node","parent","children","depth","maxChildren","data","_addNextNodeToParent","distantRelative","_findParent","nextNode","Math","floor","length","push","_reduce","Promise","all","filter","child","map","concat"],"mappings":"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","sourcesContent":["'use strict'\n\nconst batch = require('async-iterator-batch')\n\nmodule.exports = function * trickleReduceToRoot (source, reduce, options) {\n  yield trickleStream(source, reduce, options)\n}\n\nasync function trickleStream (source, reduce, options) {\n  let root\n  let iteration = 0\n  let maxDepth = 1\n  let subTree = root = new Root(options.layerRepeat)\n\n  for await (const layer of batch(source, options.maxChildrenPerNode)) {\n    if (subTree.isFull()) {\n      if (subTree !== root) {\n        root.addChild(await subTree.reduce(reduce))\n      }\n\n      if (iteration && iteration % options.layerRepeat === 0) {\n        maxDepth++\n      }\n\n      subTree = new SubTree(maxDepth, options.layerRepeat, iteration)\n\n      iteration++\n    }\n\n    subTree.append(layer)\n  }\n\n  if (subTree && subTree !== root) {\n    root.addChild(await subTree.reduce(reduce))\n  }\n\n  return root.reduce(reduce)\n}\n\nclass SubTree {\n  constructor (maxDepth, layerRepeat, iteration) {\n    this.maxDepth = maxDepth\n    this.layerRepeat = layerRepeat\n    this.currentDepth = 1\n    this.iteration = iteration\n\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    }\n  }\n\n  isFull () {\n    if (!this.root.data) {\n      return false\n    }\n\n    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n      // can descend\n      this._addNextNodeToParent(this.node)\n\n      return false\n    }\n\n    // try to find new node from node.parent\n    const distantRelative = this._findParent(this.node, this.currentDepth)\n\n    if (distantRelative) {\n      this._addNextNodeToParent(distantRelative)\n\n      return false\n    }\n\n    return true\n  }\n\n  _addNextNodeToParent (parent) {\n    this.parent = parent\n\n    // find site for new node\n    const nextNode = {\n      children: [],\n      depth: parent.depth + 1,\n      parent,\n      maxDepth: this.maxDepth,\n      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n    }\n\n    parent.children.push(nextNode)\n\n    this.currentDepth = nextNode.depth\n    this.node = nextNode\n  }\n\n  append (layer) {\n    this.node.data = layer\n  }\n\n  reduce (reduce) {\n    return this._reduce(this.root, reduce)\n  }\n\n  async _reduce (node, reduce) {\n    let children = []\n\n    if (node.children.length) {\n      children = await Promise.all(\n        node.children\n          .filter(child => child.data)\n          .map(child => this._reduce(child, reduce))\n      )\n    }\n\n    return reduce(node.data.concat(children))\n  }\n\n  _findParent (node, depth) {\n    const parent = node.parent\n\n    if (!parent || parent.depth === 0) {\n      return\n    }\n\n    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n      // this layer is full, may be able to traverse to a different branch\n      return this._findParent(parent, depth)\n    }\n\n    return parent\n  }\n}\n\nclass Root extends SubTree {\n  constructor (layerRepeat) {\n    super(0, layerRepeat)\n\n    this.root.depth = 0\n    this.currentDepth = 1\n  }\n\n  addChild (child) {\n    this.root.children.push(child)\n  }\n\n  reduce (reduce) {\n    return reduce(this.root.data.concat(this.root.children))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}