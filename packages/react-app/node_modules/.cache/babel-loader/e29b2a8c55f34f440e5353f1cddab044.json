{"ast":null,"code":"'use strict';\n\nconst crypto = require('libp2p-crypto');\n\nconst Buffer = require('safe-buffer/').Buffer;\n\nmodule.exports = {\n  verify: async (signature, publicKey, data) => {\n    if (!signature) {\n      throw new Error('No signature given');\n    }\n\n    if (!publicKey) {\n      throw new Error('Given publicKey was undefined');\n    }\n\n    if (!data) {\n      throw new Error('Given input data was undefined');\n    }\n\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data);\n    }\n\n    const isValid = (key, msg, sig) => new Promise((resolve, reject) => {\n      key.verify(msg, sig, (err, valid) => {\n        if (!err) {\n          resolve(valid);\n        }\n\n        reject(valid);\n      });\n    });\n\n    let res = false;\n\n    try {\n      const pubKey = crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(Buffer.from(publicKey, 'hex'));\n      res = await isValid(pubKey, data, Buffer.from(signature, 'hex'));\n    } catch (e) {// Catch error: sig length wrong\n    }\n\n    return Promise.resolve(res);\n  }\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/orbit-db-keystore/src/verifiers/verifierv1.js"],"names":["crypto","require","Buffer","module","exports","verify","signature","publicKey","data","Error","isBuffer","from","isValid","key","msg","sig","Promise","resolve","reject","err","valid","res","pubKey","keys","supportedKeys","secp256k1","unmarshalSecp256k1PublicKey","e"],"mappings":"AAAA;;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,cAAD,CAAP,CAAwBC,MAAvC;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,MAAM,EAAE,OAAOC,SAAP,EAAkBC,SAAlB,EAA6BC,IAA7B,KAAsC;AAC5C,QAAI,CAACF,SAAL,EAAgB;AACd,YAAM,IAAIG,KAAJ,CAAU,oBAAV,CAAN;AACD;;AACD,QAAI,CAACF,SAAL,EAAgB;AACd,YAAM,IAAIE,KAAJ,CAAU,+BAAV,CAAN;AACD;;AACD,QAAI,CAACD,IAAL,EAAW;AACT,YAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,QAAI,CAACP,MAAM,CAACQ,QAAP,CAAgBF,IAAhB,CAAL,EAA4B;AAC1BA,MAAAA,IAAI,GAAGN,MAAM,CAACS,IAAP,CAAYH,IAAZ,CAAP;AACD;;AAED,UAAMI,OAAO,GAAG,CAACC,GAAD,EAAMC,GAAN,EAAWC,GAAX,KAAmB,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAClEL,MAAAA,GAAG,CAACR,MAAJ,CAAWS,GAAX,EAAgBC,GAAhB,EAAqB,CAACI,GAAD,EAAMC,KAAN,KAAgB;AACnC,YAAI,CAACD,GAAL,EAAU;AACRF,UAAAA,OAAO,CAACG,KAAD,CAAP;AACD;;AACDF,QAAAA,MAAM,CAACE,KAAD,CAAN;AACD,OALD;AAMD,KAPkC,CAAnC;;AASA,QAAIC,GAAG,GAAG,KAAV;;AACA,QAAI;AACF,YAAMC,MAAM,GAAGtB,MAAM,CAACuB,IAAP,CAAYC,aAAZ,CAA0BC,SAA1B,CAAoCC,2BAApC,CAAgExB,MAAM,CAACS,IAAP,CAAYJ,SAAZ,EAAuB,KAAvB,CAAhE,CAAf;AACAc,MAAAA,GAAG,GAAG,MAAMT,OAAO,CAACU,MAAD,EAASd,IAAT,EAAeN,MAAM,CAACS,IAAP,CAAYL,SAAZ,EAAuB,KAAvB,CAAf,CAAnB;AACD,KAHD,CAGE,OAAOqB,CAAP,EAAU,CACV;AACD;;AACD,WAAOX,OAAO,CAACC,OAAR,CAAgBI,GAAhB,CAAP;AACD;AAjCc,CAAjB","sourcesContent":["'use strict'\nconst crypto = require('libp2p-crypto')\nconst Buffer = require('safe-buffer/').Buffer\n\nmodule.exports = {\n  verify: async (signature, publicKey, data) => {\n    if (!signature) {\n      throw new Error('No signature given')\n    }\n    if (!publicKey) {\n      throw new Error('Given publicKey was undefined')\n    }\n    if (!data) {\n      throw new Error('Given input data was undefined')\n    }\n\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data)\n    }\n\n    const isValid = (key, msg, sig) => new Promise((resolve, reject) => {\n      key.verify(msg, sig, (err, valid) => {\n        if (!err) {\n          resolve(valid)\n        }\n        reject(valid)\n      })\n    })\n\n    let res = false\n    try {\n      const pubKey = crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(Buffer.from(publicKey, 'hex'))\n      res = await isValid(pubKey, data, Buffer.from(signature, 'hex'))\n    } catch (e) {\n      // Catch error: sig length wrong\n    }\n    return Promise.resolve(res)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}